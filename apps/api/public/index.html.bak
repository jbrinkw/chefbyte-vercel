<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ChefByte IO Wizard</title>
    <style>
      :root {
        --accent: #d33;
        --accent-dark: #a11;
        --bg: #f7f7f9;
        --key: #fff;
        --key-border: #ddd;
        --key-hover: #f0f0f0;
        --active: #1e66f5;
      }
      body { font-family: system-ui, Arial, sans-serif; margin: 0; padding: 16px; background: #fff; color: #111; height: 100vh; box-sizing: border-box; display: flex; flex-direction: column; overflow: hidden; }
      h1 { margin: 8px 0 12px; font-size: 20px; font-weight: 600; }
      .status { margin: 8px 0 12px; color: #444; min-height: 20px; }
      .headerBar { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 12px; margin-bottom: 8px; }
      .headerBar .rightActions { display: flex; align-items: center; justify-content: flex-end; gap: 8px; }
      .headerBar .actionBtn { padding: 16px 20px; border: 1px solid #ccc; background: #fff; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 16px; white-space: nowrap; }
      .headerBar .actionBtn:hover { background: #f5f5f5; }
      .mealPlanToggle[data-enabled="false"] { background: #d33; color: #fff; border-color: #a11; }
      .mealPlanToggle[data-enabled="false"]:hover { background: #a11; }
      .mealPlanToggle[data-enabled="true"] { background: #2f9e44; color: #fff; border-color: #2b8a3e; }
      .mealPlanToggle[data-enabled="true"]:hover { background: #2b8a3e; }
      .modeButtons { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; width: 100%; }
      .modeBtn { padding: 14px 16px; border: 1px solid #ccc; background: #fff; border-radius: 10px; cursor: pointer; font-weight: 700; width: 100%; font-size: 16px; }
      .modeBtn.active { background: #222; color: #fff; border-color: #222; }
      .app { display: grid; grid-template-columns: 1.5fr 2.5fr; gap: 16px; align-items: stretch; flex: 1 1 auto; min-height: 0; height: auto; }
      .panel { background: var(--bg); border: 1px solid #eee; border-radius: 8px; padding: 12px; height: 100%; min-height: 0; display: flex; flex-direction: column; }
      .queuePanel { display: flex; flex-direction: column; min-height: 0; overflow: hidden; height: 100%; }
      .queueHeader { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
      .logHeader { display: flex; align-items: center; justify-content: flex-end; margin: 6px 0 8px; }
      .logFilterButtons { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; width: 100%; }
      .queueHeader input[type="text"] { flex: 1; padding: 10px 12px; border: 1px solid #ccc; border-radius: 6px; }
      .queueList { display: flex; flex-direction: column; gap: 8px; flex: 1 1 auto; min-height: 0; overflow-y: auto; padding-right: 4px; max-height: none; }
      .queueItem { display: grid; grid-template-columns: 1fr auto; grid-template-rows: auto auto; gap: 4px 8px; padding: 10px 12px; border: 1px solid #ddd; border-radius: 8px; background: #fff; cursor: pointer; }
      .queueItem.red { border-color: var(--accent); background: #ffe9e9; }
      .queueItem.active { outline: 2px solid var(--active); }
      .queueItem .name { grid-column: 1; grid-row: 1; font-weight: 600; }
      .queueItem .details { grid-column: 1; grid-row: 2; font-size: 12px; color: #666; }
      .queueItem .right { grid-column: 2; grid-row: 1 / span 2; display: flex; align-items: center; font-size: 16px; font-weight: 600; color: #000; font-variant-numeric: tabular-nums; }

      .keypadPanel { display: grid; grid-template-columns: 110px 1fr; grid-template-rows: auto auto 1fr auto; gap: 10px; min-height: 0; height: 100%; }
      .keypadPanel .modeButtons { grid-column: 1; grid-row: 1 / -1; display: flex; flex-direction: column; gap: 10px; height: 100%; }
      .keypadPanel .modeButtons .modeBtn { flex: 1 1 0; }
      .keypadPanel .activeBar, .keypadPanel .screen, .keypadPanel .nutritionEditorForm, .keypadPanel .keysGrid, .keypadPanel .completeBtn { grid-column: 2; }
      .activeBar { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
      .activeName { font-size: 24px; font-weight: 800; padding: 4px 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .modeBtn.small { padding: 8px 12px; font-size: 14px; border-radius: 8px; }
      .screen { display: flex; align-items: center; gap: 8px; }
      .screen input { flex: 1; font-size: 42px; padding: 8px 10px; border: 1px solid #ccc; border-radius: 8px; text-align: right; }
      .screen .units { font-size: 16px; color: #666; }

      .keysGrid { display: grid; grid-template-columns: repeat(3, 1fr) 0.5fr; grid-auto-rows: minmax(80px, 1fr); gap: 10px; }
      .key { background: var(--key); border: 1px solid var(--key-border); border-radius: 10px; font-size: 28px; font-weight: 700; cursor: pointer; user-select: none; display: flex; align-items: center; justify-content: center; }
      .key:hover { background: var(--key-hover); }
      .key.op { background: #fef3f3; border-color: #f2d1d1; }
      .key.op:hover { background: #fde7e7; }
      .key.unitToggle { grid-column: 4; grid-row: 1 / span 4; background: #e3f2fd; border-color: #90caf9; font-size: 14px; font-weight: 600; padding: 8px; line-height: 1.3; }
      .key.unitToggle:not(:disabled):hover { background: #bbdefb; }
      .key.unitToggle:disabled { opacity: 0.4; cursor: not-allowed; background: #f5f5f5; }
      /* specific key slots are styled by position; no extra styles needed */
      
      /* Badge styling */
      .badge { background: #2f9e44; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px; font-weight: 600; margin-left: 4px; }
      .badge.new { background: #1e88e5; }
      .badge.mp { background: #2f9e44; }

      /* Hidden debug areas */
      #logs, #modlogs { display: none; }

      .completeBtn { margin-top: 4px; padding: 24px; font-size: 18px; font-weight: 700; color: #fff; background: #2f9e44; border: 1px solid #2b8a3e; border-radius: 10px; cursor: pointer; }
      .completeBtn:hover { background: #2b8a3e; }

      /* Grocy Home Styles */
      .grocyHomeView { display: none; flex-direction: column; gap: 16px; overflow-y: auto; padding: 8px; }
      .currentDayCard { background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 16px; }
      .dayHeader { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; font-size: 18px; font-weight: 600; }
      .macroGrid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-bottom: 12px; }
      .macroBox { background: #f7f7f9; border: 1px solid #eee; border-radius: 6px; padding: 12px; text-align: center; display: flex; flex-direction: column; gap: 2px; }
      .macroBox label { display: block; font-size: 12px; color: #666; margin-bottom: 4px; text-transform: uppercase; }
      .macroBox span { font-size: 24px; font-weight: 700; color: #111; }
      .macroBox small { display: block; margin-top: 2px; }
      .statusRow { display: flex; gap: 16px; flex-wrap: wrap; font-size: 14px; color: #555; }
      .statusRow strong { color: #111; }
      
      .tempItemsSection { background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 16px; }
      .tempItemsSection h3 { margin: 0 0 12px; font-size: 16px; font-weight: 600; }
      .tempItemForm { display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 1fr auto; gap: 8px; margin-bottom: 12px; }
      .tempItemForm input { padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; }
      .tempItemForm button { padding: 8px 16px; background: #2f9e44; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; }
      .tempItemForm button:hover { background: #2b8a3e; }
      .tempItemsList { display: flex; flex-direction: column; gap: 8px; }
      .tempItem { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: #f7f7f9; border: 1px solid #eee; border-radius: 4px; }
      .tempItem .info { flex: 1; }
      .tempItem .name { font-weight: 600; margin-bottom: 4px; }
      .tempItem .macros { font-size: 13px; color: #666; }
      .tempItem button { padding: 4px 12px; background: #d33; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; }
      .tempItem button:hover { background: #a11; }

      /* LiquidTrack Styles */
      .liquidTrackSection { background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 16px; }
      .liquidTrackSection h3 { margin: 0 0 12px; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px; }
      .liquidTrackSection .sectionSubtitle { font-size: 13px; color: #666; margin: -8px 0 12px 0; }
      .scalesList { display: flex; flex-direction: column; gap: 8px; }
      .scaleCard { display: flex; justify-content: space-between; align-items: center; padding: 12px; background: #f7f7f9; border: 1px solid #eee; border-radius: 6px; cursor: pointer; transition: all 0.2s; }
      .scaleCard:hover { background: #e8f4fd; border-color: #1e66f5; }
      .scaleInfo { flex: 1; }
      .scaleInfo .scaleName { font-weight: 600; font-size: 15px; margin-bottom: 4px; }
      .scaleInfo .scaleStats { font-size: 13px; color: #666; }
      .scaleActions { display: flex; gap: 8px; align-items: center; }
      .scaleActions button { padding: 6px 12px; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; font-size: 13px; }
      .scaleActions .viewBtn { background: #1e66f5; color: #fff; }
      .scaleActions .viewBtn:hover { background: #1557d6; }
      .scaleActions .manageBtn { background: #666; color: #fff; }
      .scaleActions .manageBtn:hover { background: #555; }
      .noScalesMessage { padding: 20px; text-align: center; color: #999; font-style: italic; }

      /* LiquidTrack Modal Styles */
      .liquidModal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center; }
      .liquidModal.show { display: flex; }
      .liquidModalContent { background: #fff; border-radius: 12px; max-width: 800px; width: 90%; max-height: 90%; overflow-y: auto; padding: 24px; }
      .liquidModalHeader { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; border-bottom: 2px solid #eee; padding-bottom: 12px; }
      .liquidModalHeader h2 { margin: 0; font-size: 20px; }
      .liquidModalHeader .closeBtn { background: #d33; color: #fff; border: none; border-radius: 6px; padding: 8px 16px; cursor: pointer; font-weight: 600; }
      .liquidModalHeader .closeBtn:hover { background: #a11; }
      .dayEventsList { display: flex; flex-direction: column; gap: 8px; margin-top: 16px; }
      .eventCard { background: #f7f7f9; border: 1px solid #eee; border-radius: 6px; padding: 12px; display: flex; justify-content: space-between; align-items: center; }
      .eventCard.refill { background: #e8f5e9; border-color: #c8e6c9; }
      .eventInfo { flex: 1; }
      .eventInfo .eventProduct { font-weight: 600; margin-bottom: 4px; }
      .eventInfo .eventDetails { font-size: 13px; color: #666; }
      .eventActions button { padding: 6px 12px; background: #d33; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 13px; }
      .eventActions button:hover { background: #a11; }
      .manualEventForm { background: #f7f7f9; border: 1px solid #eee; border-radius: 6px; padding: 16px; margin-bottom: 16px; }
      .manualEventForm h4 { margin: 0 0 12px; font-size: 15px; font-weight: 600; }
      .manualEventForm .formGrid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
      .manualEventForm label { display: block; font-size: 13px; color: #666; margin-bottom: 4px; }
      .manualEventForm input, .manualEventForm select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; }
      .manualEventForm .fullWidth { grid-column: 1 / -1; }
      .manualEventForm button { margin-top: 12px; padding: 10px 20px; background: #2f9e44; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; width: 100%; }
      .manualEventForm button:hover { background: #2b8a3e; }
      .scaleManagementGrid { display: flex; flex-direction: column; gap: 12px; }
      .scaleManagementCard { background: #f7f7f9; border: 1px solid #eee; border-radius: 6px; padding: 12px; }
      .scaleManagementCard .scaleHeader { font-weight: 600; margin-bottom: 8px; }
      .scaleManagementCard .scaleDetails { font-size: 13px; color: #666; margin-bottom: 8px; }
      .scaleManagementCard button { padding: 6px 12px; background: #d33; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; }
      .scaleManagementCard button:hover { background: #a11; }

      .plannedRecipesSection { background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 16px; }
      .plannedRecipesSection h3 { margin: 0 0 12px; font-size: 16px; font-weight: 600; }
      .plannedRecipesList { display: flex; flex-direction: column; gap: 8px; }
      .plannedRecipeCard { display: flex; justify-content: space-between; align-items: center; gap: 12px; padding: 10px 12px; border: 1px solid #eee; border-radius: 6px; background: #f7f7f9; }
      .plannedRecipeInfo { display: flex; flex-direction: column; gap: 2px; }
      .plannedRecipeInfo strong { font-size: 15px; }
      .plannedRecipeMeta { font-size: 13px; color: #555; }
      .plannedRecipeActions { display: flex; gap: 8px; align-items: center; }
      .plannedRecipeActions button { padding: 8px 14px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; }
      .plannedRecipeActions button.execute { background: #1e66f5; color: #fff; }
      .plannedRecipeActions button.undo { background: #d33; color: #fff; }
      .plannedRecipeActions button:disabled { opacity: 0.6; cursor: not-allowed; }

      /* Toggle slider for meal prep */
      .mealPrepToggle { position: relative; display: inline-block; width: 44px; height: 24px; }
      .mealPrepToggle input { opacity: 0; width: 0; height: 0; }
      .mealPrepToggle .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: 0.3s; border-radius: 24px; }
      .mealPrepToggle .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: 0.3s; border-radius: 50%; }
      .mealPrepToggle input:checked + .slider { background-color: #1e66f5; }
      .mealPrepToggle input:checked + .slider:before { transform: translateX(20px); }
      .mealPrepLabel { font-size: 12px; color: #666; margin-left: 8px; }
      
      .shoppingLinksBtn { padding: 12px 20px; background: #1e66f5; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 14px; transition: background 0.2s; }
      .shoppingLinksBtn:hover { background: #1557d6; }
      .shoppingLinksBtn:disabled { opacity: 0.6; cursor: not-allowed; }
      #btnOpenMissingWalmart:hover { background: #cc6600 !important; }
      
      .recentDaysSection { background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 16px; }
      .recentDaysSection h3 { margin: 0 0 12px; font-size: 16px; font-weight: 600; }
      .dayCard { background: #f7f7f9; border: 1px solid #eee; border-radius: 6px; padding: 12px; margin-bottom: 8px; cursor: pointer; }
      .dayCard:hover { background: #f0f0f0; }
      .dayCard .dayCardHeader { display: flex; justify-content: space-between; align-items: center; font-weight: 600; }
      .dayCard .dayCardExpanded { margin-top: 12px; display: none; }
      .dayCard.expanded .dayCardExpanded { display: block; }
      .entryItem { padding: 8px; background: #fff; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 6px; }
      .entryItem .entryName { font-weight: 600; }
      .entryItem .entryMacros { font-size: 13px; color: #666; }
      .pagination { display: flex; justify-content: center; align-items: center; gap: 16px; margin-top: 16px; }
      .pagination button { padding: 8px 16px; background: #fff; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; }
      .pagination button:hover { background: #f5f5f5; }
      .pagination button:disabled { opacity: 0.5; cursor: not-allowed; }
      
      /* Walmart Manager Styles */
      .walmartManagerView { display: none; flex-direction: column; gap: 20px; overflow-y: auto; padding: 8px; }
      .managerCard { background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 20px; }
      .managerCard h2 { margin: 0 0 16px; font-size: 20px; font-weight: 600; color: #111; }
      .counterRow { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding: 12px; background: #f7f7f9; border-radius: 6px; }
      .counterRow span { font-size: 15px; color: #444; }
      .counterRow strong { font-size: 18px; color: #1e66f5; }
      .managerBtn { padding: 10px 20px; background: #1e66f5; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 14px; transition: background 0.2s; }
      .managerBtn:hover { background: #1557d6; }
      .managerBtn:disabled { opacity: 0.6; cursor: not-allowed; background: #999; }
      .completeManagerBtn { width: 100%; padding: 16px; margin-top: 20px; background: #2f9e44; color: #fff; border: none; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 16px; transition: background 0.2s; }
      .completeManagerBtn:hover { background: #2b8a3e; }
      .completeManagerBtn:disabled { opacity: 0.6; cursor: not-allowed; background: #999; }
      
      .productOptionsContainer { display: flex; flex-direction: column; gap: 24px; margin-top: 16px; }
      .productCard { background: #f7f7f9; border: 1px solid #e0e0e0; border-radius: 8px; padding: 16px; }
      .productCard .productName { font-size: 16px; font-weight: 600; color: #111; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
      .productCard .productName .searchLink { font-size: 14px; font-weight: 400; color: #1e66f5; text-decoration: none; }
      .productCard .productName .searchLink:hover { text-decoration: underline; }
      .productCard .notWalmartCheckbox { display: flex; align-items: center; gap: 6px; font-size: 13px; color: #666; font-weight: 400; }
      .productCard .notWalmartCheckbox input[type="checkbox"] { cursor: pointer; }
      .productCard .notWalmartCheckbox label { cursor: pointer; user-select: none; }
      .productCard .loadingText { color: #666; font-style: italic; padding: 20px; text-align: center; }
      .productCard .locationWarning { color: #d33; font-size: 13px; font-weight: 600; padding: 8px 12px; background: #ffe9e9; border: 1px solid #ffcccc; border-radius: 4px; margin-bottom: 12px; display: flex; align-items: center; gap: 6px; }
      .productCard .customLinkBox { margin-top: 12px; }
      .productCard .customLinkBox label { display: block; font-size: 13px; color: #666; margin-bottom: 4px; }
      .productCard .customLinkBox input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; }
      .productCard .customLinkBox input:focus { outline: none; border-color: #1e66f5; }
      .optionsGrid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; }
      .optionCard { background: #fff; border: 2px solid #ddd; border-radius: 6px; padding: 12px; cursor: pointer; transition: all 0.2s; display: flex; flex-direction: column; gap: 8px; position: relative; }
      .optionCard:hover { border-color: #1e66f5; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
      .optionCard.selected { border-color: #2f9e44; background: #f0fdf4; }
      .optionCard .optionImage { width: 100%; height: 150px; object-fit: contain; border-radius: 4px; background: #fff; }
      .optionCard .optionName { font-size: 13px; font-weight: 500; color: #333; line-height: 1.3; min-height: 36px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; }
      .optionCard .optionPrice { font-size: 18px; font-weight: 700; color: #1e66f5; text-decoration: none; display: block; }
      .optionCard .optionPrice:hover { text-decoration: underline; }
      .optionCard .radioCircle { position: absolute; top: 8px; right: 8px; width: 20px; height: 20px; border: 2px solid #ddd; border-radius: 50%; background: #fff; display: flex; align-items: center; justify-content: center; }
      .optionCard.selected .radioCircle { border-color: #2f9e44; background: #2f9e44; }
      .optionCard.selected .radioCircle::after { content: '‚úì'; color: #fff; font-size: 14px; font-weight: bold; }
      
      .priceUpdateProgress { margin-top: 16px; padding: 16px; background: #f7f7f9; border-radius: 6px; }
      .progressBar { width: 100%; height: 24px; background: #e0e0e0; border-radius: 12px; overflow: hidden; margin-bottom: 12px; }
      .progressBarFill { height: 100%; background: linear-gradient(90deg, #1e66f5, #2f9e44); transition: width 0.3s ease; border-radius: 12px; }
      .progressText { font-size: 15px; color: #444; margin-bottom: 8px; }
      .progressText strong { color: #1e66f5; font-size: 18px; }
      .errorList { margin-top: 12px; max-height: 200px; overflow-y: auto; }
      .errorItem { padding: 8px 12px; background: #ffe9e9; border: 1px solid #ffcccc; border-radius: 4px; margin-bottom: 6px; font-size: 13px; color: #c00; }

      /* Recipe Browser Styles */
      .recipesView { display: none; flex-direction: column; gap: 16px; overflow-y: auto; padding: 8px; }
      .filtersCard { background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 20px; }
      .filtersCard h3 { margin: 0 0 16px; font-size: 18px; font-weight: 600; }
      .filterRow { display: grid; grid-template-columns: 200px 1fr; gap: 12px; align-items: center; margin-bottom: 16px; }
      .filterRow label { font-size: 14px; font-weight: 500; color: #333; }
      .sliderControl { display: flex; align-items: center; gap: 12px; }
      .sliderControl input[type="range"] { flex: 1; }
      .sliderControl .sliderValue { min-width: 60px; text-align: right; font-size: 14px; color: #666; }
      .recipesGrid { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 16px; }
      .recipeCard { background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 16px; transition: all 0.2s; }
      .recipeCard:hover { border-color: #1e66f5; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
      .recipeCard .recipeName { font-size: 16px; font-weight: 600; margin-bottom: 8px; color: #111; }
      .recipeCard .recipeDescription { font-size: 13px; color: #666; margin-bottom: 12px; line-height: 1.4; }
      .recipeCard .recipeMacros { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 8px; }
      .recipeCard .macroItem { text-align: center; font-size: 12px; }
      .recipeCard .macroItem .value { display: block; font-size: 16px; font-weight: 700; color: #1e66f5; }
      .recipeCard .recipeTime { display: flex; gap: 16px; font-size: 13px; color: #666; border-top: 1px solid #eee; padding-top: 8px; }
      
      /* Nutrition Editor Styles */
      .nutritionEditorForm {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .nutritionGrid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 6px;
        flex: 1;
      }
      .nutritionField {
        display: flex;
        flex-direction: column;
        gap: 2px;
        min-width: 0;
      }
      .nutritionField label {
        font-size: 10px;
        font-weight: 600;
        color: #666;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        line-height: 1;
        margin-bottom: 2px;
      }
      .nutritionField input {
        height: 46px;
        padding: 0 4px;
        border: 1px solid #ccc;
        border-radius: 8px;
        font-size: 24px;
        transition: border-color 0.2s;
        text-align: center;
        width: 100%;
        box-sizing: border-box;
        line-height: 44px;
      }
      .nutritionField input:focus {
        outline: none;
        border-color: #1e66f5;
      }
      .nutritionField.focused input {
        border-color: #1e66f5;
        background: #f0f8ff;
      }
      .nutritionField input[readonly] {
        background: #f5f5f5;
        color: #666;
      }

      /* Modal Styles */
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        align-items: center;
        justify-content: center;
      }
      .modal.show {
        display: flex;
      }
      .modalContent {
        background: #fff;
        border-radius: 12px;
        padding: 24px;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
      }
      .modalHeader {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 16px;
      }
      .modalBody textarea {
        width: 100%;
        min-height: 200px;
        padding: 12px;
        border: 1px solid #ccc;
        border-radius: 6px;
        font-size: 14px;
        font-family: inherit;
        resize: vertical;
        box-sizing: border-box;
      }
      .modalBody textarea:focus {
        outline: none;
        border-color: #1e66f5;
      }
      .modalFooter {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
        margin-top: 16px;
      }
      .modalBtn {
        padding: 10px 20px;
        border: 1px solid #ccc;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 600;
        font-size: 14px;
      }
      .modalBtn.primary {
        background: #2f9e44;
        color: #fff;
        border-color: #2b8a3e;
      }
      .modalBtn.primary:hover {
        background: #2b8a3e;
      }
      .modalBtn.secondary {
        background: #fff;
        color: #333;
      }
      .modalBtn.secondary:hover {
        background: #f5f5f5;
      }
    </style>
  </head>
  <body>
    <div class="headerBar">
      <h1 id="pageTitle">ChefByte IO Wizard</h1>
      <div class="rightActions">
        <button id="btnToggleMealPlan" class="actionBtn mealPlanToggle" data-enabled="false" title="When enabled, consuming items will automatically add them to today's meal plan and mark as done">
          Consume: Add to Meal Plan
        </button>
        <button id="btnShowScanner" class="actionBtn">Scanner</button>
        <button id="btnShowGrocyHome" class="actionBtn">ChefByte Home</button>
        <button id="btnShowWalmart" class="actionBtn">Walmart Manager</button>
        <button id="btnShowRecipes" class="actionBtn">Recipes</button>
      </div>
    </div>
    <div class="status" id="statusText"></div>
    <div class="app">
      <div class="panel queuePanel">
        <div class="queueHeader">
          <input id="barcode" type="text" placeholder="Scan or type barcode and press Enter" />
        </div>
        <div class="logHeader">
          <div class="logFilterButtons">
            <button id="btnLogAll" class="modeBtn small active">All</button>
            <button id="btnLogNew" class="modeBtn small">Incomplete</button>
          </div>
        </div>
        <div id="queue" class="queueList"></div>
      </div>
      <div class="panel keypadPanel">
        <div class="modeButtons">
          <button id="btnPurchase" class="modeBtn active">Purchase</button>
          <button id="btnConsume" class="modeBtn">Consume</button>
          <button id="btnAddToShopping" class="modeBtn">Add to Shopping</button>
        </div>
        <div class="activeBar">
          <div id="activeName" class="activeName">No item selected</div>
        </div>
        <!-- Standard screen for non-purchase items -->
        <div class="screen" id="standardScreen">
          <input id="screen" type="text" inputmode="decimal" pattern="^\\d*\\.?\\d*$" value="1" />
          <div class="units" id="screenUnits">servings</div>
        </div>
        <!-- Nutrition editor for purchase items -->
        <div class="nutritionEditorForm" id="nutritionEditor" style="display: none;">
          <div class="nutritionGrid">
            <div class="nutritionField">
              <label>Servings/Container</label>
              <input type="text" inputmode="decimal" id="nutritionServings" />
            </div>
            <div class="nutritionField">
              <label>Calories/Serving</label>
              <input type="text" inputmode="decimal" id="nutritionCalories" />
            </div>
            <div class="nutritionField">
              <label>Carbs (g)</label>
              <input type="text" inputmode="decimal" id="nutritionCarbs" />
            </div>
            <div class="nutritionField">
              <label>Fats (g)</label>
              <input type="text" inputmode="decimal" id="nutritionFats" />
            </div>
            <div class="nutritionField">
              <label>Protein (g)</label>
              <input type="text" inputmode="decimal" id="nutritionProtein" />
            </div>
          </div>
        </div>
        <div class="keysGrid">
          <button class="key" data-digit="7">7</button>
          <button class="key" data-digit="8">8</button>
          <button class="key" data-digit="9">9</button>
          <button class="key" data-digit="4">4</button>
          <button class="key" data-digit="5">5</button>
          <button class="key" data-digit="6">6</button>
          <button class="key" data-digit="1">1</button>
          <button class="key" data-digit="2">2</button>
          <button class="key" data-digit="3">3</button>
          <button class="key dot" data-act="dot">.</button>
          <button class="key" data-digit="0">0</button>
          <button class="key backspace" data-act="backspace">‚Üê</button>
          <button id="btnUnitToggle" class="key unitToggle" disabled>Servings</button>
        </div>
        <button id="btnComplete" class="completeBtn">Complete</button>
      </div>
    </div>

    <!-- Grocy Home View -->
    <div id="grocyHomeView" class="grocyHomeView">
      <!-- Current Day Status -->
      <div class="currentDayCard">
        <div class="dayHeader">
          <span id="currentDayDate">Today</span>
          <span id="dayTimeRange" style="font-size: 14px; color: #666;">(6:00 AM - 5:59 AM)</span>
        </div>
        <div class="macroGrid">
          <div class="macroBox">
            <label>Calories</label>
            <div><span id="consumedCals">0</span> / <span id="plannedCals">0</span> / <span id="goalCals">0</span></div>
            <small style="font-size: 11px; color: #888;">consumed / planned / goal</small>
          </div>
          <div class="macroBox">
            <label>Carbs</label>
            <div><span id="consumedCarbs">0</span> / <span id="plannedCarbs">0</span> / <span id="goalCarbs">0</span>g</div>
            <small style="font-size: 11px; color: #888;">consumed / planned / goal</small>
          </div>
          <div class="macroBox">
            <label>Fats</label>
            <div><span id="consumedFats">0</span> / <span id="plannedFats">0</span> / <span id="goalFats">0</span>g</div>
            <small style="font-size: 11px; color: #888;">consumed / planned / goal</small>
          </div>
          <div class="macroBox">
            <label>Protein</label>
            <div><span id="consumedProtein">0</span> / <span id="plannedProtein">0</span> / <span id="goalProtein">0</span>g</div>
            <small style="font-size: 11px; color: #888;">consumed / planned / goal</small>
          </div>
        </div>
        
        <!-- Status indicators -->
        <div class="statusRow">
          <span>Missing Walmart Links: <strong id="missingLinks">-</strong></span>
          <span>Missing Prices: <strong id="missingPrices">-</strong></span>
          <span>Placeholder Items: <strong id="placeholderCount">-</strong></span>
          <span>Below Min Stock: <strong id="belowMinCount">-</strong></span>
          <span>Shopping Cart Value: <strong id="shoppingCartValue">$-</strong></span>
        </div>
        
        <!-- Shopping List Actions -->
        <div style="margin-top: 16px; display: flex; gap: 12px; flex-wrap: wrap;">
          <button id="btnOpenShoppingLinks" class="shoppingLinksBtn">
            üõí Open Shopping List Links
          </button>
          <button id="btnRefreshProcessedValues" class="shoppingLinksBtn" style="background: #2f9e44;">
            üîÑ Refresh Processed Values
          </button>
          <button id="btnImportShoppingList" class="shoppingLinksBtn" style="background: #ff8c00;">
            üì• Import Shopping List
          </button>
          <button id="btnMealPlanShopping" class="shoppingLinksBtn" style="background: #1e66f5;">
            üçΩÔ∏è Meal Plan ‚Üí Cart
          </button>
          <button id="btnTasteProfile" class="shoppingLinksBtn" style="background: #9b59b6;">
            üìù Taste Profile
          </button>
          <button id="btnTargetMacros" class="shoppingLinksBtn" style="background: #e67e22;">
            üéØ Target Macros
          </button>
        </div>
      </div>
      
      <!-- Temp Items Section -->
      <div class="tempItemsSection">
        <h3>Quick Add (Today)</h3>
        <div class="tempItemForm">
          <input type="text" id="tempItemName" placeholder="Item name" />
          <input type="number" id="tempItemCals" placeholder="Calories" step="1" />
          <input type="number" id="tempItemCarbs" placeholder="Carbs" step="0.1" />
          <input type="number" id="tempItemFats" placeholder="Fats" step="0.1" />
          <input type="number" id="tempItemProtein" placeholder="Protein" step="0.1" />
          <button id="btnAddTempItem">Add</button>
        </div>
        <div id="tempItemsList" class="tempItemsList">
          <!-- Temp items will be populated here -->
        </div>
      </div>

      <!-- LiquidTrack Section -->
      <div class="liquidTrackSection">
        <h3>üíß LiquidTrack</h3>
        <p class="sectionSubtitle">Monitor liquid consumption from your smart scales</p>
        <div id="scalesList" class="scalesList">
          <!-- Scales will be populated here -->
        </div>
      </div>

      <!-- LiquidTrack Day View Modal -->
      <div id="liquidDayModal" class="liquidModal">
        <div class="liquidModalContent">
          <div class="liquidModalHeader">
            <h2 id="dayModalTitle">Events for Today</h2>
            <button class="closeBtn" onclick="closeDayModal()">Close</button>
          </div>

          <!-- Manual Event Form -->
          <div class="manualEventForm" id="manualEventForm">
            <h4>Add Manual Event</h4>
            <p style="font-size: 13px; color: #666; margin-bottom: 12px;">
              Enter weight consumed OR total calories. Macros will be calculated from past events for this product.
            </p>
            <div class="formGrid">
              <div>
                <label>Product Name</label>
                <input type="text" id="manualProductName" placeholder="e.g., Whole Milk" />
              </div>
              <div>
                <label>Weight Consumed (g)</label>
                <input type="number" id="manualConsumed" placeholder="250" step="1" />
              </div>
              <div>
                <label style="text-align: center; padding: 8px 0;">‚Äî OR ‚Äî</label>
              </div>
              <div>
                <label>Total Calories</label>
                <input type="number" id="manualCaloriesTotal" placeholder="150" step="1" />
              </div>
              <div class="fullWidth">
                <label>
                  <input type="checkbox" id="manualIsRefill" />
                  This is a refill (finishing previous container + starting new one)
                </label>
              </div>
            </div>
            <button onclick="addManualEvent()">Add Event</button>
          </div>

          <!-- Events List -->
          <div id="dayEventsList" class="dayEventsList">
            <!-- Events will be populated here -->
          </div>
        </div>
      </div>

      <!-- LiquidTrack Scale Management Modal -->
      <div id="scaleManagementModal" class="liquidModal">
        <div class="liquidModalContent">
          <div class="liquidModalHeader">
            <h2>Manage Scales</h2>
            <button class="closeBtn" onclick="closeScaleManagementModal()">Close</button>
          </div>
          <div id="scaleManagementGrid" class="scaleManagementGrid">
            <!-- All scales will be listed here -->
          </div>
        </div>
      </div>

      <div class="plannedRecipesSection">
        <h3>Today's Meal Prep</h3>
        <div id="mealPrepRecipesList" class="plannedRecipesList">
          <!-- Meal prep recipes populate here -->
        </div>
      </div>

      <div class="plannedRecipesSection">
        <h3>Today's Meals</h3>
        <div id="regularMealsList" class="plannedRecipesList">
          <!-- Regular meals (recipes and products) populate here -->
        </div>
      </div>
      
      <!-- Recent Days Section -->
      <div class="recentDaysSection">
        <h3>Recent Days</h3>
        <div id="recentDaysList">
          <!-- Recent days will be populated here -->
        </div>
        <div class="pagination">
          <button id="btnPrevPage" disabled>‚Üê Prev</button>
          <span id="pageInfo">Page 1</span>
          <button id="btnNextPage" disabled>Next ‚Üí</button>
        </div>
      </div>
    </div>

    <!-- Recipes View -->
    <div id="recipesView" class="recipesView">
      <div class="filtersCard">
        <h3>Recipe Filters</h3>

        <!-- Can be made filter -->
        <div class="filterRow">
          <label>
            <input type="checkbox" id="filterCanBeMade"> Can be made now
          </label>
        </div>

        <!-- Carbs Percentile Filter -->
        <div class="filterRow">
          <label>Carbs Percentile (Top %)</label>
          <div class="sliderControl">
            <input type="range" id="filterCarbsMin" min="0" max="100" value="0" step="10">
            <span class="sliderValue"><span id="filterCarbsMinValue">0</span>%</span>
          </div>
        </div>

        <!-- Protein Percentile Filter -->
        <div class="filterRow">
          <label>Protein Percentile (Top %)</label>
          <div class="sliderControl">
            <input type="range" id="filterProteinMin" min="0" max="100" value="0" step="10">
            <span class="sliderValue"><span id="filterProteinMinValue">0</span>%</span>
          </div>
        </div>

        <!-- Max Active cook time -->
        <div class="filterRow">
          <label>Max Active cook time</label>
          <div class="sliderControl">
            <input type="range" id="filterActiveTimeMax" min="0" max="45" value="45" step="5">
            <span class="sliderValue"><span id="filterActiveTimeMaxValue">45</span> min</span>
          </div>
        </div>

        <!-- Max Total cook time -->
        <div class="filterRow">
          <label>Max Total cook time</label>
          <div class="sliderControl">
            <input type="range" id="filterTotalTimeMax" min="0" max="45" value="45" step="5">
            <span class="sliderValue"><span id="filterTotalTimeMaxValue">45</span> min</span>
          </div>
        </div>

        <button class="managerBtn" onclick="searchRecipes()">Search Recipes</button>
      </div>

      <div class="managerCard">
        <h2>Results <span id="recipeCount"></span></h2>
        <div id="recipesGrid" class="recipesGrid"></div>
      </div>
    </div>

    <!-- Walmart Manager View -->
    <div id="walmartManagerView" class="walmartManagerView">
      <!-- Missing Links Section -->
      <div class="managerCard">
        <h2>Update Missing Walmart Links</h2>
        <div class="counterRow">
          <span>Missing Links: <strong id="missingLinksCount">-</strong></span>
          <button id="btnFetchMissingLinks" class="managerBtn">Load Next 5 Products</button>
        </div>
        <div id="productOptionsContainer" class="productOptionsContainer"></div>
        <button id="btnCompleteLinkUpdates" class="completeManagerBtn" style="display:none;">Complete & Update Selected</button>
      </div>
      
      <!-- Missing Prices Section -->
      <div class="managerCard">
        <h2>Update Missing Prices</h2>
        <div class="counterRow">
          <span>Missing Prices (with links): <strong id="missingPricesCount">-</strong></span>
          <button id="btnStartPriceUpdate" class="managerBtn">Start Price Update</button>
        </div>
        <div id="priceUpdateProgress" class="priceUpdateProgress" style="display:none;">
          <div class="progressBar">
            <div id="priceProgressBar" class="progressBarFill"></div>
          </div>
          <div class="progressText">Progress: <strong id="priceProgressText">0 / 0</strong></div>
          <div id="priceErrorList" class="errorList"></div>
        </div>
        
        <!-- Manual Price Entry for Non-Walmart Items -->
        <div id="manualPriceSection" style="display:none; margin-top: 20px; padding-top: 20px; border-top: 2px solid #e0e0e0;">
          <h3 style="margin: 0 0 12px; font-size: 16px; font-weight: 600;">Manual Price Entry (Non-Walmart Items)</h3>
          <div id="manualPriceList" style="display: flex; flex-direction: column; gap: 12px;"></div>
          <button id="btnCompleteManualPrices" class="completeManagerBtn" style="display:none; margin-top: 12px;">Complete Manual Prices</button>
        </div>
      </div>
    </div>

    <div id="logs"></div>
    <div id="modlogs"></div>

    <!-- Taste Profile Modal -->
    <div id="tasteProfileModal" class="modal">
      <div class="modalContent">
        <div class="modalHeader">Taste Profile</div>
        <div class="modalBody">
          <textarea id="tasteProfileText" placeholder="Enter your taste preferences, dietary restrictions, favorite ingredients, etc."></textarea>
        </div>
        <div class="modalFooter">
          <button id="btnCancelTasteProfile" class="modalBtn secondary">Cancel</button>
          <button id="btnUpdateTasteProfile" class="modalBtn primary">Update</button>
        </div>
      </div>
    </div>

    <!-- Target Macros Modal -->
    <div id="targetMacrosModal" class="modal">
      <div class="modalContent">
        <div class="modalHeader">Target Macros</div>
        <div class="modalBody">
          <div style="display: flex; flex-direction: column; gap: 16px;">
            <div style="display: flex; flex-direction: column; gap: 4px;">
              <label style="font-weight: 600; font-size: 14px;">Carbs (g)</label>
              <input type="number" id="targetCarbs" step="1" min="0" style="padding: 10px; border: 1px solid #ccc; border-radius: 6px; font-size: 16px;">
            </div>
            <div style="display: flex; flex-direction: column; gap: 4px;">
              <label style="font-weight: 600; font-size: 14px;">Protein (g)</label>
              <input type="number" id="targetProtein" step="1" min="0" style="padding: 10px; border: 1px solid #ccc; border-radius: 6px; font-size: 16px;">
            </div>
            <div style="display: flex; flex-direction: column; gap: 4px;">
              <label style="font-weight: 600; font-size: 14px;">Fats (g)</label>
              <input type="number" id="targetFats" step="1" min="0" style="padding: 10px; border: 1px solid #ccc; border-radius: 6px; font-size: 16px;">
            </div>
            <div style="padding: 16px; background: #f7f7f9; border-radius: 6px; border: 2px solid #1e66f5;">
              <div style="font-size: 12px; color: #666; margin-bottom: 4px;">Total Calories (calculated)</div>
              <div id="calculatedCalories" style="font-size: 32px; font-weight: 700; color: #1e66f5;">0</div>
            </div>
          </div>
        </div>
        <div class="modalFooter">
          <button id="btnCancelTargetMacros" class="modalBtn secondary">Cancel</button>
          <button id="btnUpdateTargetMacros" class="modalBtn primary">Update</button>
        </div>
      </div>
    </div>

    <!-- Automation Config Modal -->
    <div id="automationModal" class="modal">
      <div class="modalContent" style="max-width: 600px;">
        <div class="modalHeader">Automation Settings</div>
        <div class="modalBody">
          <div style="display: flex; flex-direction: column; gap: 20px;">
            
            <!-- Enable Auto-Run Toggle -->
            <div style="padding: 16px; background: #f7f7f9; border-radius: 8px;">
              <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                <input type="checkbox" id="autoRunEnabled" style="width: 20px; height: 20px; cursor: pointer;">
                <div>
                  <div style="font-weight: 600; font-size: 16px;">Enable Auto-Run</div>
                  <div style="font-size: 13px; color: #666; margin-top: 4px;">Automatically run selected scripts every minute</div>
                </div>
              </label>
            </div>

            <!-- Script Selection -->
            <div>
              <div style="font-weight: 600; margin-bottom: 12px; font-size: 15px;">Select Scripts to Run:</div>
              <div style="display: flex; flex-direction: column; gap: 12px;">
                <label style="display: flex; align-items: center; gap: 10px; padding: 12px; background: #fff; border: 2px solid #e0e0e0; border-radius: 6px; cursor: pointer;">
                  <input type="checkbox" id="scriptRecipeMacros" value="update_recipe_macros" class="automation-script-checkbox" style="width: 18px; height: 18px; cursor: pointer;">
                  <div>
                    <div style="font-weight: 600;">Recipe Macros</div>
                    <div style="font-size: 12px; color: #666;">Update recipe macro calculations</div>
                  </div>
                </label>
                <label style="display: flex; align-items: center; gap: 10px; padding: 12px; background: #fff; border: 2px solid #e0e0e0; border-radius: 6px; cursor: pointer;">
                  <input type="checkbox" id="scriptShoppingList" value="add_below_min_to_shopping" class="automation-script-checkbox" style="width: 18px; height: 18px; cursor: pointer;">
                  <div>
                    <div style="font-weight: 600;">Shopping List</div>
                    <div style="font-size: 12px; color: #666;">Add below-minimum items to shopping list</div>
                  </div>
                </label>
                <label style="display: flex; align-items: center; gap: 10px; padding: 12px; background: #fff; border: 2px solid #e0e0e0; border-radius: 6px; cursor: pointer;">
                  <input type="checkbox" id="scriptMealProducts" value="create_meal_products" class="automation-script-checkbox" style="width: 18px; height: 18px; cursor: pointer;">
                  <div>
                    <div style="font-weight: 600;">Meal Products</div>
                    <div style="font-size: 12px; color: #666;">Create [MEAL] products from recipes</div>
                  </div>
                </label>
              </div>
            </div>

            <!-- Status Display -->
            <div style="padding: 16px; background: #e7f5ff; border-radius: 8px; border: 2px solid #1e66f5;">
              <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                <div>
                  <div style="font-size: 12px; color: #666;">Last Run</div>
                  <div id="automationLastRun" style="font-weight: 600; font-size: 14px;">Never</div>
                </div>
                <div style="text-align: right;">
                  <div style="font-size: 12px; color: #666;">Next Run</div>
                  <div id="automationNextRun" style="font-weight: 600; font-size: 14px;">-</div>
                </div>
              </div>
              <div id="automationStatus" style="font-size: 13px; color: #1e66f5; margin-top: 8px;">‚óè  Idle</div>
            </div>

            <!-- Recent Runs (Collapsible) -->
            <div>
              <button id="btnToggleAutomationLog" style="width: 100%; text-align: left; padding: 12px; background: #f0f0f0; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; display: flex; justify-content: space-between; align-items: center;">
                <span>Recent Runs</span>
                <span id="automationLogToggleIcon">‚ñº</span>
              </button>
              <div id="automationLogContainer" style="display: none; margin-top: 8px; max-height: 200px; overflow-y: auto; padding: 12px; background: #f9f9f9; border-radius: 6px;">
                <div id="automationLogContent" style="font-size: 13px; color: #666;">Loading...</div>
              </div>
            </div>

          </div>
        </div>
        <div class="modalFooter" style="display: flex; gap: 12px;">
          <button id="btnRunNow" class="modalBtn" style="background: #2f9e44; color: white; flex: 1;">‚ñ∂Ô∏è Run Now</button>
          <button id="btnCancelAutomation" class="modalBtn secondary" style="flex: 0.5;">Cancel</button>
          <button id="btnSaveAutomation" class="modalBtn primary" style="flex: 0.5;">Save</button>
        </div>
      </div>
    </div>

    <!-- Missing Walmart Links Warning Modal -->
    <div id="missingLinksWarningModal" class="modal">
      <div class="modalContent" style="max-width: 600px;">
        <div class="modalHeader" style="background: #ff6b6b; color: white;">‚ö†Ô∏è Missing Walmart Links</div>
        <div class="modalBody">
          <div style="margin-bottom: 16px;">
            <p style="font-size: 15px; line-height: 1.5; margin-bottom: 12px;">
              <strong>Cannot add meal plan to cart:</strong> The following products in your meal plan are missing Walmart links.
            </p>
            <p style="font-size: 14px; color: #666; margin-bottom: 16px;">
              Please add Walmart links for these products in the <strong>Walmart Manager</strong> before syncing to cart.
            </p>
          </div>

          <div style="max-height: 300px; overflow-y: auto; border: 2px solid #e0e0e0; border-radius: 6px; padding: 12px; background: #f9f9f9;">
            <div id="missingLinksList" style="display: flex; flex-direction: column; gap: 8px;"></div>
          </div>

          <div style="margin-top: 16px; padding: 12px; background: #e7f5ff; border-radius: 6px; border: 2px solid #1e66f5;">
            <div style="font-size: 13px; color: #1e66f5;">
              <strong>üí° Tip:</strong> Click "Go to Walmart Manager" to quickly add links for these products.
            </div>
          </div>
        </div>
        <div class="modalFooter" style="display: flex; gap: 12px;">
          <button id="btnCancelMissingLinks" class="modalBtn secondary" style="flex: 1;">Cancel</button>
          <button id="btnGoToWalmartManager" class="modalBtn primary" style="flex: 1; background: #1e66f5;">Go to Walmart Manager</button>
        </div>
      </div>
    </div>

    <script>
      // Global configuration (loaded from server)
      let APP_CONFIG = {
        default_shopping_list_id: 1  // Fallback default
      };

      // Load configuration from server on page load
      (async function loadConfig() {
        try {
          const res = await fetch('./api/config/client');
          if (res.ok) {
            APP_CONFIG = await res.json();
            console.log('[ChefByte] Loaded config:', APP_CONFIG);
          }
        } catch (err) {
          console.warn('[ChefByte] Failed to load config, using defaults:', err);
        }
      })();

      // Helper function to escape HTML for safe rendering
      function escapeHtml(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
      }

      const statusText = document.getElementById('statusText');
      const barcodeInput = document.getElementById('barcode');
      const queueEl = document.getElementById('queue');
      const screen = document.getElementById('screen');
      const logsEl = document.getElementById('logs');
      const modlogsEl = document.getElementById('modlogs');
      const btnPurchase = document.getElementById('btnPurchase');
      const btnConsume = document.getElementById('btnConsume');
      const btnComplete = document.getElementById('btnComplete');
      const btnAddToShopping = document.getElementById('btnAddToShopping');
      const btnLogAll = document.getElementById('btnLogAll');
      const btnLogNew = document.getElementById('btnLogNew');
      const btnToggleMealPlan = document.getElementById('btnToggleMealPlan');
      const btnUnitToggle = document.getElementById('btnUnitToggle');
      const screenUnits = document.querySelector('.screen .units');

      // Meal plan toggle state
      let mealPlanEnabled = false;

      // Unit toggle state (servings or containers)
      let unitMode = 'servings';
      
      // Recipe densities for percentile filtering
      let recipeProteinDensities = [];
      let recipeCarbsDensities = [];

      // Grocy Home Elements
      const pageTitle = document.getElementById('pageTitle');
      const btnShowScanner = document.getElementById('btnShowScanner');
      const btnShowGrocyHome = document.getElementById('btnShowGrocyHome');
      const btnShowWalmart = document.getElementById('btnShowWalmart');
      const btnShowRecipes = document.getElementById('btnShowRecipes');
      const appView = document.querySelector('.app');
      const grocyHomeView = document.getElementById('grocyHomeView');
      const walmartManagerView = document.getElementById('walmartManagerView');
      const recipesView = document.getElementById('recipesView');
      const btnAddTempItem = document.getElementById('btnAddTempItem');
      const tempItemsList = document.getElementById('tempItemsList');
      let currentView = 'scanner'; // 'scanner', 'home', 'walmart', or 'recipes'
      let refreshInterval = null; // For auto-refresh
      let currentMealPrepKey = '';
      let currentRegularMealsKey = '';

      // Update button states and meal plan button visibility
      function updatePageButtons() {
        // Reset all buttons
        btnShowScanner.classList.remove('active');
        btnShowGrocyHome.classList.remove('active');
        btnShowWalmart.classList.remove('active');
        btnShowRecipes.classList.remove('active');

        // Set active button
        if (currentView === 'scanner') {
          btnShowScanner.classList.add('active');
          btnShowScanner.style.background = '#222';
          btnShowScanner.style.color = '#fff';
          btnShowGrocyHome.style.background = '';
          btnShowGrocyHome.style.color = '';
          btnShowWalmart.style.background = '';
          btnShowWalmart.style.color = '';
          btnShowRecipes.style.background = '';
          btnShowRecipes.style.color = '';
          btnToggleMealPlan.style.display = ''; // Show on scanner page
        } else if (currentView === 'home') {
          btnShowGrocyHome.classList.add('active');
          btnShowGrocyHome.style.background = '#222';
          btnShowGrocyHome.style.color = '#fff';
          btnShowScanner.style.background = '';
          btnShowScanner.style.color = '';
          btnShowWalmart.style.background = '';
          btnShowWalmart.style.color = '';
          btnShowRecipes.style.background = '';
          btnShowRecipes.style.color = '';
          btnToggleMealPlan.style.display = 'none'; // Hide on non-scanner pages
        } else if (currentView === 'walmart') {
          btnShowWalmart.classList.add('active');
          btnShowWalmart.style.background = '#222';
          btnShowWalmart.style.color = '#fff';
          btnShowScanner.style.background = '';
          btnShowScanner.style.color = '';
          btnShowGrocyHome.style.background = '';
          btnShowGrocyHome.style.color = '';
          btnShowRecipes.style.background = '';
          btnShowRecipes.style.color = '';
          btnToggleMealPlan.style.display = 'none'; // Hide on non-scanner pages
        } else if (currentView === 'recipes') {
          btnShowRecipes.classList.add('active');
          btnShowRecipes.style.background = '#222';
          btnShowRecipes.style.color = '#fff';
          btnShowScanner.style.background = '';
          btnShowScanner.style.color = '';
          btnShowGrocyHome.style.background = '';
          btnShowGrocyHome.style.color = '';
          btnShowWalmart.style.background = '';
          btnShowWalmart.style.color = '';
          btnToggleMealPlan.style.display = 'none'; // Hide on non-scanner pages
        }
      }

      // Page switching functions
      function showScanner() {
        // Stop any existing refresh intervals
        if (refreshInterval) {
          clearInterval(refreshInterval);
          refreshInterval = null;
        }

        appView.style.display = 'grid';
        grocyHomeView.style.display = 'none';
        walmartManagerView.style.display = 'none';
        recipesView.style.display = 'none';
        pageTitle.textContent = 'ChefByte IO Wizard';
        currentView = 'scanner';
        updatePageButtons();
      }
      
      function showGrocyHome() {
        // Stop any existing refresh intervals
        if (refreshInterval) {
          clearInterval(refreshInterval);
          refreshInterval = null;
        }
        
        appView.style.display = 'none';
        grocyHomeView.style.display = 'flex';
        walmartManagerView.style.display = 'none';
        recipesView.style.display = 'none';
        pageTitle.textContent = 'ChefByte Home';
        currentView = 'home';
        updatePageButtons();
        
        // Initial load includes day history + planned entries
        loadGrocyHome(true);
        loadPlannedEntries(false);
        
        // Start auto-refresh for live metrics; throttle to reduce flashing
        refreshInterval = setInterval(() => {
          loadGrocyHome(false); // Don't reload history on auto-refresh
          loadPlannedEntries(true);
        }, 10000);
      }
      
      function showWalmartManager() {
        // Stop any existing refresh intervals
        if (refreshInterval) {
          clearInterval(refreshInterval);
          refreshInterval = null;
        }

        appView.style.display = 'none';
        grocyHomeView.style.display = 'none';
        walmartManagerView.style.display = 'flex';
        recipesView.style.display = 'none';
        pageTitle.textContent = 'Walmart Manager';
        currentView = 'walmart';
        updatePageButtons();

        // Load Walmart Manager data
        loadWalmartManager();
      }

      function showRecipesView() {
        // Stop any existing refresh intervals
        if (refreshInterval) {
          clearInterval(refreshInterval);
          refreshInterval = null;
        }

        appView.style.display = 'none';
        grocyHomeView.style.display = 'none';
        walmartManagerView.style.display = 'none';
        recipesView.style.display = 'flex';
        pageTitle.textContent = 'Recipe Browser';
        currentView = 'recipes';
        updatePageButtons();
        
        // Load recipe densities for percentile filtering (protein & carbs)
        loadRecipeDensities();
      }
      
      function loadRecipeDensities() {
        // Load all recipe protein densities for percentile calculation
        fetch('./api/recipes/protein-densities')
          .then(res => res.json())
          .then(data => {
            recipeProteinDensities = data.recipes || [];
            console.log(`Loaded ${recipeProteinDensities.length} recipes for protein percentile filtering`);
          })
          .catch(err => {
            console.error('Error loading protein densities:', err);
            recipeProteinDensities = [];
          });
        
        // Load all recipe carbs densities for percentile calculation
        fetch('./api/recipes/carbs-densities')
          .then(res => res.json())
          .then(data => {
            recipeCarbsDensities = data.recipes || [];
            console.log(`Loaded ${recipeCarbsDensities.length} recipes for carbs percentile filtering`);
          })
          .catch(err => {
            console.error('Error loading carbs densities:', err);
            recipeCarbsDensities = [];
          });
      }
      
      // Wire up page buttons
      btnShowScanner.addEventListener('click', showScanner);
      btnShowGrocyHome.addEventListener('click', showGrocyHome);
      btnShowWalmart.addEventListener('click', showWalmartManager);
      btnShowRecipes.addEventListener('click', showRecipesView);
      
      // Initialize button states and show scanner view by default
      showScanner();
      
      // Meal Plan Toggle Handler
      btnToggleMealPlan.addEventListener('click', () => {
        mealPlanEnabled = !mealPlanEnabled;
        btnToggleMealPlan.setAttribute('data-enabled', mealPlanEnabled.toString());
        btnToggleMealPlan.title = mealPlanEnabled 
          ? 'ENABLED: Consuming items will automatically add them to today\'s meal plan and mark as done. Click to disable.'
          : 'DISABLED: Consuming items will NOT add to meal plan. Click to enable.';
        
        // When enabling meal plan, automatically switch to consume mode
        if (mealPlanEnabled) {
          setMode('remove');
        }
        
        // Update unit mode if in consume mode
        if (scanOp === 'remove') {
          unitMode = mealPlanEnabled ? 'servings' : 'containers';
          updateScreenUnits();
        }
      });

      // Grocy Home Functions
      async function fetchDaySummary(day = null) {
        const url = day ? `./api/macros/day-summary?day=${day}` : './api/macros/day-summary';
        const res = await fetch(url);
        return await res.json();
      }

      async function fetchStatusCounts() {
        const res = await fetch('./api/status/counts');
        return await res.json();
      }

      async function createTempItem(itemData) {
        const res = await fetch('./api/temp-items', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(itemData)
        });
        return await res.json();
      }

      async function deleteTempItem(id) {
        const res = await fetch(`./api/temp-items/${id}`, { method: 'DELETE' });
        return await res.json();
      }

      async function loadGrocyHome(includeHistory = false) {
        try {
          // Load day summary
          const daySummary = await fetchDaySummary();
          updateDaySummary(daySummary);

          // Load status counts
          const counts = await fetchStatusCounts();
          updateStatusCounts(counts);

          // Load temp items for today
          loadTempItems(daySummary);

          // Load LiquidTrack scales
          loadLiquidTrackScales();

          // Load recent days only on initial load (not on auto-refresh)
          if (includeHistory) {
            loadRecentDays(currentRecentDaysPage);
          }
        } catch (err) {
          console.error('Error loading Grocy Home:', err);
        }
      }

      // ==============================
      // LiquidTrack Functions
      // ==============================
      let currentDayScale = null;
      let currentDayDate = null;

      async function loadLiquidTrackScales() {
        try {
          const res = await fetch('./liquid/scales/active');
          const scales = await res.json();

          const scalesList = document.getElementById('scalesList');
          if (!scales || scales.length === 0) {
            scalesList.innerHTML = '<div class="noScalesMessage">No active scales detected. Scales will appear here after first use.</div>';
            return;
          }

          scalesList.innerHTML = scales.map(scale => `
            <div class="scaleCard" onclick="viewScaleDetailsPopup('${escapeHtml(scale.scale_id)}')" style="cursor: pointer;">
              <div class="scaleInfo">
                <div class="scaleName">${escapeHtml(scale.scale_id)}</div>
                <div class="scaleStats">
                  ${scale.last_product ? `Tracking: <strong>${escapeHtml(scale.last_product)}</strong><br>` : ''}
                  Today: ${scale.today_consumption}g (${scale.today_events} events) |
                  Cal: ${Math.round(scale.today_calories || 0)} |
                  P: ${(scale.today_protein || 0).toFixed(1)}g |
                  C: ${(scale.today_carbs || 0).toFixed(1)}g |
                  F: ${(scale.today_fat || 0).toFixed(1)}g
                </div>
              </div>
              <div class="scaleActions" onclick="event.stopPropagation()">
                <button class="viewBtn" onclick="viewScaleDay('${escapeHtml(scale.scale_id)}', 'today')">Log Manual Entry</button>
                <button class="manageBtn" onclick="openScaleManagement()">Manage</button>
              </div>
            </div>
          `).join('');
        } catch (err) {
          console.error('Error loading LiquidTrack scales:', err);
          document.getElementById('scalesList').innerHTML = '<div class="noScalesMessage">Error loading scales. Check console for details.</div>';
        }
      }

      async function viewScaleDetailsPopup(scaleId) {
        // Show modal with today's events for this scale
        const date = new Date().toISOString().split('T')[0];
        currentDayScale = scaleId;
        currentDayDate = date;

        const modal = document.getElementById('liquidDayModal');
        const titleEl = document.getElementById('dayModalTitle');
        const eventsListEl = document.getElementById('dayEventsList');
        const formEl = document.getElementById('manualEventForm');

        titleEl.textContent = `${scaleId} - Today's Events`;
        formEl.style.display = 'none'; // Hide manual entry form when viewing events
        modal.classList.add('show');

        try {
          const res = await fetch(`./liquid/scales/${encodeURIComponent(scaleId)}/day/${date}`);

          if (!res.ok) {
            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
          }

          const data = await res.json();

          if (!data.events || data.events.length === 0) {
            eventsListEl.innerHTML = '<div class="noScalesMessage">No events recorded today.</div>';
            return;
          }

          // Show summary at top
          const summaryHtml = `
            <div style="background: #f5f5f5; padding: 12px; border-radius: 6px; margin-bottom: 16px;">
              <strong>Today's Total:</strong><br>
              ${data.summary.total_consumed}g consumed |
              ${Math.round(data.summary.total_calories)} cal |
              P: ${data.summary.total_protein.toFixed(1)}g |
              C: ${data.summary.total_carbs.toFixed(1)}g |
              F: ${data.summary.total_fat.toFixed(1)}g
            </div>
          `;

          // Show events list with delete buttons
          const eventsHtml = data.events.map(event => `
            <div class="eventCard ${event.is_refill ? 'refill' : ''}">
              <div class="eventInfo">
                <div class="eventProduct">${escapeHtml(event.product_name)} ${event.is_refill ? '(Refill)' : ''}</div>
                <div class="eventDetails">
                  ${new Date(event.created_at).toLocaleTimeString()} |
                  ${event.is_refill ? 'Added' : 'Consumed'}: ${Math.round(event.consumed)}g |
                  Cal: ${Math.round(event.calories)} |
                  P: ${event.protein.toFixed(1)}g |
                  C: ${event.carbs.toFixed(1)}g |
                  F: ${event.fat.toFixed(1)}g
                </div>
              </div>
              <div class="eventActions">
                <button onclick="deleteEventAndRefresh(${event.id})">Delete</button>
              </div>
            </div>
          `).join('');

          eventsListEl.innerHTML = summaryHtml + eventsHtml;
        } catch (err) {
          console.error('Error loading scale details:', err);
          eventsListEl.innerHTML = `<div class="noScalesMessage">Error loading events: ${err.message}</div>`;
        }
      }

      async function viewScaleDay(scaleId, dateOrToday) {
        currentDayScale = scaleId;
        currentDayDate = dateOrToday === 'today' ? new Date().toISOString().split('T')[0] : dateOrToday;

        const modal = document.getElementById('liquidDayModal');
        const titleEl = document.getElementById('dayModalTitle');
        const eventsListEl = document.getElementById('dayEventsList');
        const formEl = document.getElementById('manualEventForm');

        titleEl.textContent = `Log Manual Entry for ${scaleId}`;
        formEl.style.display = 'block'; // Show manual entry form
        modal.classList.add('show');

        try {
          const res = await fetch(`/api/liquid/scales/${encodeURIComponent(scaleId)}/day/${currentDayDate}`);
          const data = await res.json();

          if (!data.events || data.events.length === 0) {
            eventsListEl.innerHTML = '<div class="noScalesMessage">No events recorded for this day.</div>';
            return;
          }

          eventsListEl.innerHTML = data.events.map(event => `
            <div class="eventCard ${event.is_refill ? 'refill' : ''}">
              <div class="eventInfo">
                <div class="eventProduct">${escapeHtml(event.product_name)} ${event.is_refill ? '(Refill)' : ''}</div>
                <div class="eventDetails">
                  ${new Date(event.created_at).toLocaleTimeString()} |
                  ${event.is_refill ? 'Added' : 'Consumed'}: ${Math.round(event.consumed)}g |
                  Cal: ${Math.round(event.calories)} |
                  P: ${event.protein.toFixed(1)}g |
                  C: ${event.carbs.toFixed(1)}g |
                  F: ${event.fat.toFixed(1)}g
                </div>
              </div>
              <div class="eventActions">
                <button onclick="deleteEvent(${event.id})">Delete</button>
              </div>
            </div>
          `).join('');
        } catch (err) {
          console.error('Error loading day events:', err);
          eventsListEl.innerHTML = '<div class="noScalesMessage">Error loading events. Check console for details.</div>';
        }
      }

      function closeDayModal() {
        document.getElementById('liquidDayModal').classList.remove('show');
        currentDayScale = null;
        currentDayDate = null;
        // Clear manual form
        document.getElementById('manualProductName').value = '';
        document.getElementById('manualConsumed').value = '';
        document.getElementById('manualCaloriesTotal').value = '';
        document.getElementById('manualIsRefill').checked = false;
      }

      async function addManualEvent() {
        if (!currentDayScale) {
          alert('No scale selected');
          return;
        }

        const productName = document.getElementById('manualProductName').value.trim();
        const consumedInput = parseFloat(document.getElementById('manualConsumed').value) || 0;
        const caloriesInput = parseFloat(document.getElementById('manualCaloriesTotal').value) || 0;
        const isRefill = document.getElementById('manualIsRefill').checked;

        if (!productName) {
          alert('Please enter product name');
          return;
        }

        if (consumedInput <= 0 && caloriesInput <= 0) {
          alert('Please enter either weight consumed OR total calories');
          return;
        }

        if (consumedInput > 0 && caloriesInput > 0) {
          alert('Please enter only ONE: weight consumed OR calories (not both)');
          return;
        }

        try {
          // Fetch historical data for this product to get ratios
          const historyRes = await fetch(`./liquid/product-history?product_name=${encodeURIComponent(productName)}`);
          const history = await historyRes.json();

          let consumed, calories, protein, carbs, fat;

          if (history.avg_calories_per_100g) {
            // Calculate from historical ratios
            if (consumedInput > 0) {
              // User entered weight, calculate calories/macros
              consumed = consumedInput;
              const ratio = consumed / 100;
              calories = history.avg_calories_per_100g * ratio;
              protein = history.avg_protein_per_100g * ratio;
              carbs = history.avg_carbs_per_100g * ratio;
              fat = history.avg_fat_per_100g * ratio;
            } else {
              // User entered calories, calculate weight/macros
              calories = caloriesInput;
              consumed = (calories / history.avg_calories_per_100g) * 100;
              const ratio = consumed / 100;
              protein = history.avg_protein_per_100g * ratio;
              carbs = history.avg_carbs_per_100g * ratio;
              fat = history.avg_fat_per_100g * ratio;
            }
          } else {
            // No history, use input directly with zeros for macros
            consumed = consumedInput || (caloriesInput / 1) * 100; // Rough estimate if no history
            calories = caloriesInput || 0;
            protein = 0;
            carbs = 0;
            fat = 0;
          }

          const res = await fetch('./liquid/events/manual', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              scale_id: currentDayScale,
              product_name: productName,
              consumed,
              calories,
              protein,
              carbs,
              fat,
              is_refill: isRefill
            })
          });

          if (res.ok) {
            // Close modal
            closeDayModal();
            // Reload scales list to update totals
            await loadLiquidTrackScales();
          } else {
            const error = await res.json();
            alert(`Error: ${error.error || 'Failed to add event'}`);
          }
        } catch (err) {
          console.error('Error adding manual event:', err);
          alert('Failed to add event. Check console for details.');
        }
      }

      async function deleteEvent(eventId) {
        if (!confirm('Delete this event?')) return;

        try {
          const res = await fetch(`./liquid/events/${eventId}`, {
            method: 'DELETE'
          });

          if (res.ok) {
            // Reload day view
            await viewScaleDay(currentDayScale, currentDayDate);
            // Reload scales list to update totals
            await loadLiquidTrackScales();
          } else {
            const error = await res.json();
            alert(`Error: ${error.error || 'Failed to delete event'}`);
          }
        } catch (err) {
          console.error('Error deleting event:', err);
          alert('Failed to delete event. Check console for details.');
        }
      }

      async function deleteEventAndRefresh(eventId) {
        if (!confirm('Delete this event?')) return;

        try {
          const res = await fetch(`./liquid/events/${eventId}`, {
            method: 'DELETE'
          });

          if (res.ok) {
            // Refresh the popup with updated data
            await viewScaleDetailsPopup(currentDayScale);
            // Reload scales list to update totals
            await loadLiquidTrackScales();
          } else {
            const error = await res.json();
            alert(`Error: ${error.error || 'Failed to delete event'}`);
          }
        } catch (err) {
          console.error('Error deleting event:', err);
          alert('Failed to delete event. Check console for details.');
        }
      }

      async function openScaleManagement() {
        const modal = document.getElementById('scaleManagementModal');
        const gridEl = document.getElementById('scaleManagementGrid');

        modal.classList.add('show');

        try {
          const res = await fetch('./liquid/scales/all');
          const scales = await res.json();

          if (!scales || scales.length === 0) {
            gridEl.innerHTML = '<div class="noScalesMessage">No scales found in database.</div>';
            return;
          }

          gridEl.innerHTML = scales.map(scale => `
            <div class="scaleManagementCard">
              <div class="scaleHeader">${escapeHtml(scale.scale_id)}</div>
              <div class="scaleDetails">
                First seen: ${new Date(scale.first_seen).toLocaleDateString()} |
                Last event: ${new Date(scale.last_event).toLocaleString()} |
                Total events: ${scale.total_events}
              </div>
            </div>
          `).join('');
        } catch (err) {
          console.error('Error loading all scales:', err);
          gridEl.innerHTML = '<div class="noScalesMessage">Error loading scales. Check console for details.</div>';
        }
      }

      function closeScaleManagementModal() {
        document.getElementById('scaleManagementModal').classList.remove('show');
      }

      // Close modals when clicking outside
      document.getElementById('liquidDayModal')?.addEventListener('click', (e) => {
        if (e.target.id === 'liquidDayModal') closeDayModal();
      });
      document.getElementById('scaleManagementModal')?.addEventListener('click', (e) => {
        if (e.target.id === 'scaleManagementModal') closeScaleManagementModal();
      });

      // ==============================
      // End LiquidTrack Functions
      // ==============================

      async function loadPlannedEntries(isAutoRefresh = false) {
        if (!mealPrepRecipesList && !regularMealsList) return;
        if (!isAutoRefresh && mealPrepRecipesList) {
          mealPrepRecipesList.innerHTML = '<div class="plannedRecipeCard">Loading meal prep...</div>';
        }
        if (!isAutoRefresh && regularMealsList) {
          regularMealsList.innerHTML = '<div class="plannedRecipeCard">Loading meals...</div>';
        }
        try {
          const res = await fetch('./api/meal-plan/today');
          const data = await res.json();
          const mealPrepEntries = Array.isArray(data.mealPrepRecipes) ? data.mealPrepRecipes : [];
          const recipeEntries = Array.isArray(data.regularMeals?.recipes) ? data.regularMeals.recipes : [];
          const productEntries = Array.isArray(data.regularMeals?.products) ? data.regularMeals.products : [];

          const mealPrepKey = JSON.stringify(mealPrepEntries.map((entry) => ({
            id: entry.id,
            done: !!entry.done,
            servings: Number(entry.recipe_servings || entry.base_servings || 1)
          })));
          const regularMealsKey = JSON.stringify([...recipeEntries, ...productEntries].map((entry) => ({
            id: entry.id,
            type: entry.type,
            done: !!entry.done
          })));

          if (mealPrepRecipesList && (!isAutoRefresh || mealPrepKey !== currentMealPrepKey)) {
            if (!mealPrepEntries.length) {
              mealPrepRecipesList.innerHTML = '<div class="plannedRecipeCard">No meal prep recipes for today.</div>';
            } else {
              mealPrepRecipesList.innerHTML = '';
              mealPrepEntries.forEach((entry) => {
                mealPrepRecipesList.appendChild(createMealPrepRecipeCard(entry));
              });
            }
            currentMealPrepKey = mealPrepKey;
          }

          if (regularMealsList && (!isAutoRefresh || regularMealsKey !== currentRegularMealsKey)) {
            if (!recipeEntries.length && !productEntries.length) {
              regularMealsList.innerHTML = '<div class="plannedRecipeCard">No meals planned for today.</div>';
            } else {
              regularMealsList.innerHTML = '';
              recipeEntries.forEach((entry) => {
                regularMealsList.appendChild(createRegularMealCard(entry, 'recipe'));
              });
              productEntries.forEach((entry) => {
                regularMealsList.appendChild(createRegularMealCard(entry, 'product'));
              });
            }
            currentRegularMealsKey = regularMealsKey;
          }
        } catch (err) {
          console.error('Error loading planned entries:', err);
          if (mealPrepRecipesList) {
            mealPrepRecipesList.innerHTML = '<div class="plannedRecipeCard">Failed to load meal prep.</div>';
          }
          if (regularMealsList) {
            regularMealsList.innerHTML = '<div class="plannedRecipeCard">Failed to load meals.</div>';
          }
        }
      }

      function createMealPrepRecipeCard(entry) {
        const card = document.createElement('div');
        card.className = 'plannedRecipeCard';

        const info = document.createElement('div');
        info.className = 'plannedRecipeInfo';
        const title = document.createElement('strong');
        title.textContent = entry.recipe_name || `Recipe ${entry.recipe_id}`;
        const servings = Number(entry.recipe_servings || entry.base_servings || 1);
        const meta = document.createElement('div');
        meta.className = 'plannedRecipeMeta';
        meta.textContent = `${servings} serving${servings === 1 ? '' : 's'} ¬∑ ${entry.done ? 'Completed' : 'Pending'}`;

        info.appendChild(title);
        info.appendChild(meta);

        const actions = document.createElement('div');
        actions.className = 'plannedRecipeActions';

        // Add toggle slider to move back to regular meals
        const toggleContainer = document.createElement('div');
        toggleContainer.style.display = 'flex';
        toggleContainer.style.alignItems = 'center';
        toggleContainer.style.gap = '6px';

        const toggleLabel = document.createElement('label');
        toggleLabel.className = 'mealPrepToggle';
        const toggleInput = document.createElement('input');
        toggleInput.type = 'checkbox';
        toggleInput.checked = entry.meal_prep; // Use actual meal_prep value from entry
        toggleInput.addEventListener('change', async () => {
          const wasChecked = toggleInput.checked;
          try {
            toggleInput.disabled = true;
            statusText.textContent = 'Toggling meal prep status...';
            const res = await fetch(`./api/meal-plan/${entry.id}/toggle-meal-prep`, { method: 'POST' });
            if (!res.ok) {
              throw new Error(`HTTP ${res.status}: ${res.statusText}`);
            }
            const data = await res.json();
            console.log('Toggle response:', data);
            if (data.success) {
              statusText.textContent = `Moved to ${data.meal_prep ? 'Meal Prep' : 'Regular Meals'}`;
              // Reload the entries to reflect the change
              await loadPlannedEntries(false);
            } else {
              throw new Error(data.error || 'Toggle failed');
            }
          } catch (err) {
            console.error('Error toggling meal prep:', err);
            statusText.textContent = `Failed to toggle meal prep: ${err.message}`;
            toggleInput.checked = !wasChecked; // Revert on error
            toggleInput.disabled = false;
          }
        });
        const toggleSlider = document.createElement('span');
        toggleSlider.className = 'slider';
        toggleLabel.appendChild(toggleInput);
        toggleLabel.appendChild(toggleSlider);

        const labelText = document.createElement('span');
        labelText.className = 'mealPrepLabel';
        labelText.textContent = 'Meal Prep';

        toggleContainer.appendChild(toggleLabel);
        toggleContainer.appendChild(labelText);
        actions.appendChild(toggleContainer);

        // Add execute/undo button
        const actionBtn = document.createElement('button');
        actionBtn.textContent = entry.done ? 'Undo' : 'Execute';
        actionBtn.classList.add(entry.done ? 'undo' : 'execute');
        actionBtn.addEventListener('click', () => handleMealPrepToggle(entry, !entry.done, actionBtn));
        actions.appendChild(actionBtn);

        card.appendChild(info);
        card.appendChild(actions);
        return card;
      }

      function createRegularMealCard(entry, type) {
        const card = document.createElement('div');
        card.className = 'plannedRecipeCard';

        const info = document.createElement('div');
        info.className = 'plannedRecipeInfo';
        const title = document.createElement('strong');

        if (type === 'recipe') {
          title.textContent = `${entry.recipe_name || `Recipe ${entry.recipe_id}`} (Recipe)`;
          const servings = Number(entry.recipe_servings || entry.base_servings || 1);
          const meta = document.createElement('div');
          meta.className = 'plannedRecipeMeta';
          meta.textContent = `${servings} serving${servings === 1 ? '' : 's'} ¬∑ ${entry.done ? 'Completed' : 'Pending'}`;
          info.appendChild(title);
          info.appendChild(meta);
        } else {
          title.textContent = `${entry.product_name || `Product ${entry.product_id}`} (Meal)`;
          const amount = Number(entry.product_amount || entry.amount || 1);
          const meta = document.createElement('div');
          meta.className = 'plannedRecipeMeta';
          meta.textContent = `${amount} planned ¬∑ ${entry.done ? 'Completed' : 'Pending'}`;
          info.appendChild(title);
          info.appendChild(meta);
        }

        const actions = document.createElement('div');
        actions.className = 'plannedRecipeActions';

        // Add toggle slider for recipe entries only
        if (type === 'recipe') {
          const toggleContainer = document.createElement('div');
          toggleContainer.style.display = 'flex';
          toggleContainer.style.alignItems = 'center';
          toggleContainer.style.gap = '6px';

          const toggleLabel = document.createElement('label');
          toggleLabel.className = 'mealPrepToggle';
          const toggleInput = document.createElement('input');
          toggleInput.type = 'checkbox';
          toggleInput.checked = entry.meal_prep; // Use actual meal_prep value from entry
          toggleInput.addEventListener('change', async () => {
            const wasChecked = toggleInput.checked;
            try {
              toggleInput.disabled = true;
              statusText.textContent = 'Toggling meal prep status...';
              const res = await fetch(`./api/meal-plan/${entry.id}/toggle-meal-prep`, { method: 'POST' });
              if (!res.ok) {
                throw new Error(`HTTP ${res.status}: ${res.statusText}`);
              }
              const data = await res.json();
              console.log('Toggle response:', data);
              if (data.success) {
                statusText.textContent = `Moved to ${data.meal_prep ? 'Meal Prep' : 'Regular Meals'}`;
                // Reload the entries to reflect the change
                await loadPlannedEntries(false);
              } else {
                throw new Error(data.error || 'Toggle failed');
              }
            } catch (err) {
              console.error('Error toggling meal prep:', err);
              statusText.textContent = `Failed to toggle meal prep: ${err.message}`;
              toggleInput.checked = !wasChecked; // Revert on error
              toggleInput.disabled = false;
            }
          });
          const toggleSlider = document.createElement('span');
          toggleSlider.className = 'slider';
          toggleLabel.appendChild(toggleInput);
          toggleLabel.appendChild(toggleSlider);

          const labelText = document.createElement('span');
          labelText.className = 'mealPrepLabel';
          labelText.textContent = 'Meal Prep';

          toggleContainer.appendChild(toggleLabel);
          toggleContainer.appendChild(labelText);
          actions.appendChild(toggleContainer);
        }

        // Add mark done button
        const actionBtn = document.createElement('button');
        actionBtn.textContent = entry.done ? 'Undo' : 'Mark Done';
        actionBtn.classList.add(entry.done ? 'undo' : 'execute');
        actionBtn.addEventListener('click', () => handleRegularMealToggle(entry, !entry.done, actionBtn));
        actions.appendChild(actionBtn);

        card.appendChild(info);
        card.appendChild(actions);
        return card;
      }

      async function handleMealPrepToggle(entry, shouldExecute, button) {
        const entryId = entry.id;
        if (!Number.isFinite(Number(entryId))) return;
        const entryLabel = entry.recipe_name || `Recipe ${entryId}`;
        const originalLabel = button.textContent;
        button.disabled = true;
        button.textContent = shouldExecute ? 'Executing...' : 'Undoing...';
        try {
          const res = await fetch(`./api/meal-plan/${entryId}/execute`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: shouldExecute ? 'execute' : 'undo' })
          });
          const payload = await res.json();
          if (!res.ok) throw new Error(payload.error || 'Meal prep execution failed');
          statusText.textContent = shouldExecute
            ? `Executed ${entryLabel} - consumed ingredients and produced meal products`
            : `Undid ${entryLabel} meal prep`;
          await loadGrocyHome();
          await loadPlannedEntries();
        } catch (err) {
          console.error('Error executing meal prep:', err);
          statusText.textContent = `Meal prep action failed: ${err.message || err}`;
        } finally {
          button.disabled = false;
          button.textContent = originalLabel;
        }
      }

      async function handleRegularMealToggle(entry, shouldMarkDone, button) {
        const entryId = entry.id;
        if (!Number.isFinite(Number(entryId))) return;
        const entryLabel = entry.recipe_name || entry.product_name || `Entry ${entryId}`;
        const originalLabel = button.textContent;
        button.disabled = true;
        button.textContent = shouldMarkDone ? 'Marking...' : 'Undoing...';
        try {
          const res = await fetch(`./api/meal-plan/${entryId}/mark-done`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });
          const payload = await res.json();
          if (!res.ok) throw new Error(payload.error || 'Failed to mark meal done');
          statusText.textContent = shouldMarkDone
            ? `Marked ${entryLabel} as done`
            : `Unmarked ${entryLabel}`;
          await loadGrocyHome();
          await loadPlannedEntries();
        } catch (err) {
          console.error('Error marking meal done:', err);
          statusText.textContent = `Failed to update meal: ${err.message || err}`;
        } finally {
          button.disabled = false;
          button.textContent = originalLabel;
        }
      }

      function updateDaySummary(data) {
        document.getElementById('currentDayDate').textContent = data.day || 'Today';
        
        const consumedCals = data.consumed?.calories || 0;
        const plannedCals = data.planned?.calories || 0;
        const goalCals = data.goal?.calories || 0;
        const consumedCarbs = data.consumed?.carbs || 0;
        const plannedCarbs = data.planned?.carbs || 0;
        const goalCarbs = data.goal?.carbs || 0;
        const consumedFats = data.consumed?.fats || 0;
        const plannedFats = data.planned?.fats || 0;
        const goalFats = data.goal?.fats || 0;
        const consumedProtein = data.consumed?.protein || 0;
        const plannedProtein = data.planned?.protein || 0;
        const goalProtein = data.goal?.protein || 0;
        
        // Update consumed/planned/goal format
        document.getElementById('consumedCals').textContent = consumedCals;
        document.getElementById('plannedCals').textContent = plannedCals;
        document.getElementById('goalCals').textContent = goalCals;
        
        document.getElementById('consumedCarbs').textContent = consumedCarbs.toFixed(1);
        document.getElementById('plannedCarbs').textContent = plannedCarbs.toFixed(1);
        document.getElementById('goalCarbs').textContent = goalCarbs.toFixed(1);
        
        document.getElementById('consumedFats').textContent = consumedFats.toFixed(1);
        document.getElementById('plannedFats').textContent = plannedFats.toFixed(1);
        document.getElementById('goalFats').textContent = goalFats.toFixed(1);
        
        document.getElementById('consumedProtein').textContent = consumedProtein.toFixed(1);
        document.getElementById('plannedProtein').textContent = plannedProtein.toFixed(1);
        document.getElementById('goalProtein').textContent = goalProtein.toFixed(1);
      }

      function updateStatusCounts(counts) {
        document.getElementById('missingLinks').textContent = counts.missing_walmart_links || 0;
        document.getElementById('missingPrices').textContent = counts.missing_prices || 0;
        document.getElementById('placeholderCount').textContent = counts.placeholder_count || 0;
        document.getElementById('belowMinCount').textContent = counts.below_min_count || 0;
        document.getElementById('shoppingCartValue').textContent = '$' + (counts.shopping_cart_value || '0.00');
      }

      function loadTempItems(daySummary) {
        const tempItems = daySummary.consumed?.entries?.filter(e => e.type === 'temp') || [];
        tempItemsList.innerHTML = '';

        // Only display temp items (liquid items have their own dedicated section below)
        tempItems.forEach(item => {
          const div = document.createElement('div');
          div.className = 'tempItem';
          div.innerHTML = `
            <div class="info">
              <div class="name">${item.name}</div>
              <div class="macros">${item.calories}cal ‚Ä¢ ${item.carbs}g C ‚Ä¢ ${item.fats}g F ‚Ä¢ ${item.protein}g P</div>
            </div>
            <button onclick="handleDeleteTempItem(${item.id})">Delete</button>
          `;
          tempItemsList.appendChild(div);
        });
      }

      btnAddTempItem.addEventListener('click', async () => {
        const name = document.getElementById('tempItemName').value.trim();
        const calories = parseFloat(document.getElementById('tempItemCals').value) || 0;
        const carbs = parseFloat(document.getElementById('tempItemCarbs').value) || 0;
        const fats = parseFloat(document.getElementById('tempItemFats').value) || 0;
        const protein = parseFloat(document.getElementById('tempItemProtein').value) || 0;

        if (!name || calories === 0) {
          alert('Please enter item name and calories');
          return;
        }

        try {
          await createTempItem({ name, calories, carbs, fats, protein });
          
          // Clear form
          document.getElementById('tempItemName').value = '';
          document.getElementById('tempItemCals').value = '';
          document.getElementById('tempItemCarbs').value = '';
          document.getElementById('tempItemFats').value = '';
          document.getElementById('tempItemProtein').value = '';

          // Reload Grocy Home
          loadGrocyHome();
        } catch (err) {
          console.error('Error creating temp item:', err);
          alert('Failed to create temp item');
        }
      });

      async function handleDeleteTempItem(id) {
        if (!confirm('Delete this temp item?')) return;
        
        try {
          await deleteTempItem(id);
          loadGrocyHome();
        } catch (err) {
          console.error('Error deleting temp item:', err);
          alert('Failed to delete temp item');
        }
      }

      // Open shopping list links
      const btnOpenShoppingLinks = document.getElementById('btnOpenShoppingLinks');
      if (btnOpenShoppingLinks) {
        btnOpenShoppingLinks.addEventListener('click', async () => {
          try {
            btnOpenShoppingLinks.disabled = true;
            btnOpenShoppingLinks.textContent = '‚è≥ Loading...';

            const res = await fetch(`./api/shopping/cart-links?shopping_list_id=${APP_CONFIG.default_shopping_list_id}`);
            const data = await res.json();

            console.log('Cart links response:', data);

            if (!res.ok || data.error) {
              throw new Error(data.error || 'Failed to fetch shopping links');
            }

            if (!data.cart_link && (!data.items || data.items.length === 0)) {
              alert('‚ùå No items in shopping list\n\nThe shopping list appears to be empty.');
              btnOpenShoppingLinks.textContent = 'üõí Open Shopping List Links';
              btnOpenShoppingLinks.disabled = false;
              return;
            }

            // Check if there are items without Walmart links
            const missingLinks = data.items.filter(item => item.link_type === 'missing_link');

            // If there are missing links, show a warning
            if (missingLinks.length > 0) {
              let message = `‚ö†Ô∏è Some items excluded from cart link:\n\n`;
              message += `Missing Walmart links (${missingLinks.length}):\n`;
              message += missingLinks.map(item => `‚Ä¢ ${item.product_name}`).join('\n');
              message += `\n\n`;

              if (data.cart_link) {
                message += `Opening cart with ${data.item_count} item(s)...`;
              } else {
                message += `No items available to add to cart. Please use the Walmart Manager to add links.`;
                alert(message);
                btnOpenShoppingLinks.textContent = 'üõí Open Shopping List Links';
                btnOpenShoppingLinks.disabled = false;
                return;
              }

              alert(message);
            }

            // Open the single deep link if available
            if (data.cart_link) {
              window.open(data.cart_link, '_blank');

              const listInfo = data.shopping_list_id ? ` (List ${data.shopping_list_id})` : '';
              const msg = `‚úÖ Opened cart with ${data.item_count} item(s)${listInfo}`;
              btnOpenShoppingLinks.textContent = msg;
              setTimeout(() => {
                btnOpenShoppingLinks.textContent = 'üõí Open Shopping List Links';
                btnOpenShoppingLinks.disabled = false;
              }, 3000);
            } else {
              alert('No valid cart link generated');
              btnOpenShoppingLinks.textContent = 'üõí Open Shopping List Links';
              btnOpenShoppingLinks.disabled = false;
            }
          } catch (err) {
            console.error('Error opening shopping links:', err);
            alert('Failed to open shopping links: ' + err.message);
            btnOpenShoppingLinks.textContent = 'üõí Open Shopping List Links';
          } finally {
            btnOpenShoppingLinks.disabled = false;
          }
        });
        
        // Automation Modal - Open button
        const btnRefreshProcessedValues = document.getElementById('btnRefreshProcessedValues');
        const automationModal = document.getElementById('automationModal');
        
        btnRefreshProcessedValues.addEventListener('click', () => {
          openAutomationModal();
        });

        // Automation Modal Functions
        async function openAutomationModal() {
          try {
            // Fetch current config
            const configRes = await fetch('./api/automation-config');
            const config = await configRes.json();

            // Populate form
            document.getElementById('autoRunEnabled').checked = config.enabled;
            document.getElementById('scriptRecipeMacros').checked = config.scripts.includes('update_recipe_macros');
            document.getElementById('scriptShoppingList').checked = config.scripts.includes('add_below_min_to_shopping');
            document.getElementById('scriptMealProducts').checked = config.scripts.includes('create_meal_products');

            // Update status display
            await updateAutomationStatus();

            // Load recent runs
            await loadAutomationLog();

            // Show modal
            automationModal.style.display = 'flex';
          } catch (err) {
            console.error('Error opening automation modal:', err);
            alert('Failed to load automation settings');
          }
        }

        async function updateAutomationStatus() {
          try {
            const statusRes = await fetch('./api/automation-status');
            const status = await statusRes.json();

            // Update last run
            const lastRunEl = document.getElementById('automationLastRun');
            if (status.lastRun) {
              const lastRunDate = new Date(status.lastRun);
              lastRunEl.textContent = lastRunDate.toLocaleString();
            } else {
              lastRunEl.textContent = 'Never';
            }

            // Update next run
            const nextRunEl = document.getElementById('automationNextRun');
            if (status.nextRun && status.enabled) {
              const nextRunDate = new Date(status.nextRun);
              nextRunEl.textContent = nextRunDate.toLocaleString();
            } else {
              nextRunEl.textContent = status.enabled ? 'Soon' : '-';
            }

            // Update status indicator
            const statusEl = document.getElementById('automationStatus');
            if (status.isRunning) {
              statusEl.textContent = '‚óè  Running...';
              statusEl.style.color = '#f59f00';
            } else if (status.enabled) {
              statusEl.textContent = '‚óè  Enabled';
              statusEl.style.color = '#2f9e44';
            } else {
              statusEl.textContent = '‚óè  Disabled';
              statusEl.style.color = '#999';
            }
          } catch (err) {
            console.error('Error updating automation status:', err);
          }
        }

        async function loadAutomationLog() {
          try {
            const logRes = await fetch('./api/automation-log');
            const log = await logRes.json();

            const logContent = document.getElementById('automationLogContent');
            
            if (log.length === 0) {
              logContent.innerHTML = '<div style="color: #999; font-style: italic;">No runs yet</div>';
              return;
            }

            const logHTML = log.slice(-10).reverse().map(entry => {
              const date = new Date(entry.timestamp);
              const statusColor = entry.status === 'success' ? '#2f9e44' : (entry.status === 'partial' ? '#f59f00' : '#e03131');
              const statusIcon = entry.status === 'success' ? '‚úÖ' : (entry.status === 'partial' ? '‚ö†Ô∏è' : '‚ùå');
              
              return `
                <div style="padding: 8px; margin-bottom: 6px; background: white; border-radius: 4px; border-left: 3px solid ${statusColor};">
                  <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span style="font-weight: 600;">${statusIcon} ${entry.status.toUpperCase()}</span>
                    <span style="font-size: 11px; color: #999;">${date.toLocaleString()}</span>
                  </div>
                  <div style="font-size: 11px; color: #666;">
                    ${entry.scripts.join(', ')} ‚Ä¢ ${entry.duration}ms ‚Ä¢ ${entry.trigger}
                  </div>
                </div>
              `;
            }).join('');

            logContent.innerHTML = logHTML;
          } catch (err) {
            console.error('Error loading automation log:', err);
          }
        }

        // Toggle automation log
        document.getElementById('btnToggleAutomationLog').addEventListener('click', () => {
          const container = document.getElementById('automationLogContainer');
          const icon = document.getElementById('automationLogToggleIcon');
          
          if (container.style.display === 'none') {
            container.style.display = 'block';
            icon.textContent = '‚ñ≤';
            loadAutomationLog();
          } else {
            container.style.display = 'none';
            icon.textContent = '‚ñº';
          }
        });

        // Save automation config
        document.getElementById('btnSaveAutomation').addEventListener('click', async () => {
          try {
            const enabled = document.getElementById('autoRunEnabled').checked;
            const scripts = [];
            
            if (document.getElementById('scriptRecipeMacros').checked) scripts.push('update_recipe_macros');
            if (document.getElementById('scriptShoppingList').checked) scripts.push('add_below_min_to_shopping');
            if (document.getElementById('scriptMealProducts').checked) scripts.push('create_meal_products');

            const res = await fetch('./api/automation-config', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ enabled, scripts, runEveryMinutes: 1 })
            });

            if (!res.ok) {
              throw new Error('Failed to save automation config');
            }

            alert('Automation settings saved!');
            automationModal.style.display = 'none';
          } catch (err) {
            console.error('Error saving automation config:', err);
            alert('Failed to save automation settings');
          }
        });

        // Run Now button
        document.getElementById('btnRunNow').addEventListener('click', async () => {
          try {
            const btnRunNow = document.getElementById('btnRunNow');
            btnRunNow.disabled = true;
            btnRunNow.textContent = '‚è≥ Running...';

            // Get selected scripts
            const scripts = [];
            if (document.getElementById('scriptRecipeMacros').checked) scripts.push('update_recipe_macros');
            if (document.getElementById('scriptShoppingList').checked) scripts.push('add_below_min_to_shopping');
            if (document.getElementById('scriptMealProducts').checked) scripts.push('create_meal_products');

            if (scripts.length === 0) {
              alert('Please select at least one script to run');
              btnRunNow.disabled = false;
              btnRunNow.textContent = '‚ñ∂Ô∏è Run Now';
              return;
            }

            const res = await fetch('./api/refresh-processed-values', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ scripts, trigger: 'manual' })
            });

            const data = await res.json();

            if (data.status === 'success') {
              btnRunNow.textContent = '‚úÖ Success!';
            } else if (data.status === 'partial') {
              btnRunNow.textContent = '‚ö†Ô∏è Partial';
            } else {
              btnRunNow.textContent = '‚ùå Failed';
            }

            // Reload log and status
            await updateAutomationStatus();
            await loadAutomationLog();

            setTimeout(() => {
              btnRunNow.textContent = '‚ñ∂Ô∏è Run Now';
              btnRunNow.disabled = false;
            }, 2000);
          } catch (err) {
            console.error('Error running automation:', err);
            document.getElementById('btnRunNow').textContent = '‚ùå Error';
            setTimeout(() => {
              document.getElementById('btnRunNow').textContent = '‚ñ∂Ô∏è Run Now';
              document.getElementById('btnRunNow').disabled = false;
            }, 2000);
          }
        });

        // Cancel automation modal
        document.getElementById('btnCancelAutomation').addEventListener('click', () => {
          automationModal.style.display = 'none';
        });

        // Poll automation status every 10 seconds when modal is open
        let automationStatusInterval;
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.attributeName === 'style') {
              if (automationModal.style.display === 'flex') {
                // Modal opened, start polling
                automationStatusInterval = setInterval(updateAutomationStatus, 10000);
              } else {
                // Modal closed, stop polling
                if (automationStatusInterval) {
                  clearInterval(automationStatusInterval);
                }
              }
            }
          });
        });
        observer.observe(automationModal, { attributes: true });
        
        // Import Shopping List button
      const btnImportShoppingList = document.getElementById('btnImportShoppingList');
      const mealPrepRecipesList = document.getElementById('mealPrepRecipesList');
      const regularMealsList = document.getElementById('regularMealsList');
        btnImportShoppingList.addEventListener('click', async () => {
          try {
            // Confirm before importing
            if (!confirm('Import all non-placeholder items from the shopping list to inventory?\n\nThis will add 1 container per shopping list entry.')) {
              return;
            }
            
            btnImportShoppingList.disabled = true;
            btnImportShoppingList.textContent = '‚è≥ Importing...';

            const res = await fetch('./api/import-shopping-list', { 
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ shopping_list_id: APP_CONFIG.default_shopping_list_id })
            });
            const data = await res.json();

            if (!res.ok) {
              throw new Error(data.message || 'Failed to import shopping list');
            }

            // Show success message
            const msg = `‚úÖ Imported ${data.purchased_count}, Removed ${data.removed_count || 0}`;
            btnImportShoppingList.textContent = msg;
            console.log(`Successfully imported: ${data.message}`);
            
            if (data.errors && data.errors.length > 0) {
              console.warn('Some items had errors:', data.errors);
            }

            // Refresh the page data to show updated values
            setTimeout(() => {
              loadGrocyHome();
              btnImportShoppingList.textContent = 'üì• Import Shopping List';
              btnImportShoppingList.disabled = false;
            }, 3000);
          } catch (err) {
            console.error('Error importing shopping list:', err);
            btnImportShoppingList.textContent = '‚ùå Error';
            setTimeout(() => {
              btnImportShoppingList.textContent = 'üì• Import Shopping List';
              btnImportShoppingList.disabled = false;
            }, 3000);
          }
        });

        // Meal Plan ‚Üí Cart button
        const btnMealPlanShopping = document.getElementById('btnMealPlanShopping');
        if (btnMealPlanShopping) {
          btnMealPlanShopping.addEventListener('click', async () => {
            const originalLabel = btnMealPlanShopping.textContent;
            btnMealPlanShopping.disabled = true;
            btnMealPlanShopping.textContent = '‚è≥ Validating...';
            statusText.textContent = 'Validating Walmart links for meal plan products...';

            try {
              // First, validate that all products have Walmart links
              const validationResponse = await fetch('./api/meal-plan/validate-links', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ days: 7 })
              });

              let validationData = null;
              try {
                validationData = await validationResponse.json();
              } catch (_) {
                validationData = null;
              }

              if (!validationResponse.ok) {
                const errMsg = (validationData && validationData.error) ? validationData.error : validationResponse.statusText;
                throw new Error(errMsg || 'Validation failed');
              }

              // Check if validation failed
              if (!validationData.valid) {
                // Show warning modal with missing products
                const modal = document.getElementById('missingLinksWarningModal');
                const missingLinksList = document.getElementById('missingLinksList');

                // Populate the missing products list
                missingLinksList.innerHTML = '';
                if (validationData.error) {
                  missingLinksList.innerHTML = `<div style="color: #ff6b6b; padding: 8px;">${validationData.error}</div>`;
                } else if (Array.isArray(validationData.missing_products) && validationData.missing_products.length > 0) {
                  validationData.missing_products.forEach(product => {
                    const productDiv = document.createElement('div');
                    productDiv.style.cssText = 'padding: 10px; background: white; border-radius: 4px; border: 1px solid #e0e0e0;';
                    productDiv.innerHTML = `
                      <div style="font-weight: 600; font-size: 14px;">${product.name}</div>
                      <div style="font-size: 12px; color: #666; margin-top: 4px;">Product ID: ${product.id}</div>
                      ${product.error ? `<div style="font-size: 12px; color: #ff6b6b; margin-top: 4px;">Error: ${product.error}</div>` : ''}
                    `;
                    missingLinksList.appendChild(productDiv);
                  });
                }

                modal.style.display = 'flex';
                statusText.textContent = `Validation failed: ${validationData.missing_products.length} product(s) missing Walmart links`;
                btnMealPlanShopping.textContent = originalLabel;
                btnMealPlanShopping.disabled = false;
                return;
              }

              // Validation passed, proceed with sync
              btnMealPlanShopping.textContent = '‚è≥ Syncing...';
              statusText.textContent = 'Syncing the next 7 days of the meal plan to the shopping list...';

              const response = await fetch('./api/meal-plan/shopping-diff', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ days: 7, apply: true })
              });
              let payload = null;
              try {
                payload = await response.json();
              } catch (_) {
                payload = null;
              }
              if (!response.ok) {
                const errMsg = (payload && payload.error) ? payload.error : response.statusText;
                throw new Error(errMsg || 'Meal plan sync failed');
              }
              const appliedCount = Array.isArray(payload?.applied) ? payload.applied.length : 0;
              if (appliedCount > 0) {
                statusText.textContent = `Meal plan sync complete: added ${appliedCount} item(s) to the shopping list`;
              } else {
                statusText.textContent = 'Meal plan sync complete: shopping list already satisfied';
              }
              if (Array.isArray(payload?.messages) && payload.messages.length > 0) {
                statusText.textContent += ` (${payload.messages.join('; ')})`;
              }
              if (Array.isArray(payload?.placeholder_warnings) && payload.placeholder_warnings.length > 0) {
                alert('Placeholder products limited to 1 container:\n' + payload.placeholder_warnings.join(', '));
              }
              await loadGrocyHome();
            } catch (err) {
              console.error('Error syncing meal plan to cart:', err);
              statusText.textContent = `Meal plan sync failed: ${err.message || err}`;
            } finally {
              btnMealPlanShopping.textContent = originalLabel;
              btnMealPlanShopping.disabled = false;
            }
          });
        }

        // Missing Links Warning Modal event handlers
        const missingLinksWarningModal = document.getElementById('missingLinksWarningModal');
        const btnCancelMissingLinks = document.getElementById('btnCancelMissingLinks');
        const btnGoToWalmartManager = document.getElementById('btnGoToWalmartManager');

        if (btnCancelMissingLinks) {
          btnCancelMissingLinks.addEventListener('click', () => {
            missingLinksWarningModal.style.display = 'none';
          });
        }

        if (btnGoToWalmartManager) {
          btnGoToWalmartManager.addEventListener('click', () => {
            missingLinksWarningModal.style.display = 'none';
            // Navigate to Walmart Manager view
            const btnShowWalmart = document.getElementById('btnShowWalmart');
            if (btnShowWalmart) {
              btnShowWalmart.click();
            }
          });
        }

        // Close modal when clicking outside of it
        if (missingLinksWarningModal) {
          missingLinksWarningModal.addEventListener('click', (e) => {
            if (e.target === missingLinksWarningModal) {
              missingLinksWarningModal.style.display = 'none';
            }
          });
        }

        // Taste Profile button
        const btnTasteProfile = document.getElementById('btnTasteProfile');
        const tasteProfileModal = document.getElementById('tasteProfileModal');
        const tasteProfileText = document.getElementById('tasteProfileText');
        const btnUpdateTasteProfile = document.getElementById('btnUpdateTasteProfile');
        const btnCancelTasteProfile = document.getElementById('btnCancelTasteProfile');

        btnTasteProfile.addEventListener('click', async () => {
          try {
            // Load current taste profile
            const res = await fetch('./api/config/taste-profile');
            const data = await res.json();
            tasteProfileText.value = data.taste_profile || '';
            tasteProfileModal.classList.add('show');
          } catch (err) {
            console.error('Error loading taste profile:', err);
            alert('Failed to load taste profile');
          }
        });

        btnCancelTasteProfile.addEventListener('click', () => {
          tasteProfileModal.classList.remove('show');
        });

        btnUpdateTasteProfile.addEventListener('click', async () => {
          try {
            btnUpdateTasteProfile.disabled = true;
            btnUpdateTasteProfile.textContent = 'Saving...';

            const res = await fetch('./api/config/taste-profile', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ taste_profile: tasteProfileText.value })
            });
            const data = await res.json();

            if (!res.ok || !data.success) {
              throw new Error('Failed to update taste profile');
            }

            btnUpdateTasteProfile.textContent = '‚úÖ Saved!';
            setTimeout(() => {
              tasteProfileModal.classList.remove('show');
              btnUpdateTasteProfile.textContent = 'Update';
              btnUpdateTasteProfile.disabled = false;
            }, 1000);
          } catch (err) {
            console.error('Error updating taste profile:', err);
            alert('Failed to update taste profile');
            btnUpdateTasteProfile.textContent = 'Update';
            btnUpdateTasteProfile.disabled = false;
          }
        });

        // Close modal when clicking outside
        tasteProfileModal.addEventListener('click', (e) => {
          if (e.target === tasteProfileModal) {
            tasteProfileModal.classList.remove('show');
          }
        });

        // Target Macros button
        const btnTargetMacros = document.getElementById('btnTargetMacros');
        const targetMacrosModal = document.getElementById('targetMacrosModal');
        const targetCarbs = document.getElementById('targetCarbs');
        const targetProtein = document.getElementById('targetProtein');
        const targetFats = document.getElementById('targetFats');
        const calculatedCalories = document.getElementById('calculatedCalories');
        const btnUpdateTargetMacros = document.getElementById('btnUpdateTargetMacros');
        const btnCancelTargetMacros = document.getElementById('btnCancelTargetMacros');

        // Function to calculate calories from macros
        function calculateCalories() {
          const carbs = parseFloat(targetCarbs.value) || 0;
          const protein = parseFloat(targetProtein.value) || 0;
          const fats = parseFloat(targetFats.value) || 0;

          // Carbs: 4 cal/g, Protein: 4 cal/g, Fats: 9 cal/g
          const calories = Math.round((carbs * 4) + (protein * 4) + (fats * 9));
          calculatedCalories.textContent = calories;
        }

        // Add input listeners for auto-calculation
        targetCarbs.addEventListener('input', calculateCalories);
        targetProtein.addEventListener('input', calculateCalories);
        targetFats.addEventListener('input', calculateCalories);

        btnTargetMacros.addEventListener('click', async () => {
          try {
            // Load current macro goals
            const res = await fetch('./api/config/macro-goals');
            const data = await res.json();

            targetCarbs.value = data.carbs || 0;
            targetProtein.value = data.protein || 0;
            targetFats.value = data.fats || 0;

            calculateCalories();
            targetMacrosModal.classList.add('show');
          } catch (err) {
            console.error('Error loading macro goals:', err);
            alert('Failed to load macro goals');
          }
        });

        btnCancelTargetMacros.addEventListener('click', () => {
          targetMacrosModal.classList.remove('show');
        });

        btnUpdateTargetMacros.addEventListener('click', async () => {
          try {
            btnUpdateTargetMacros.disabled = true;
            btnUpdateTargetMacros.textContent = 'Saving...';

            const carbs = parseFloat(targetCarbs.value) || 0;
            const protein = parseFloat(targetProtein.value) || 0;
            const fats = parseFloat(targetFats.value) || 0;
            const calories = parseInt(calculatedCalories.textContent) || 0;

            const res = await fetch('./api/config/macro-goals', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ carbs, protein, fats, calories })
            });
            const data = await res.json();

            if (!res.ok || !data.success) {
              throw new Error('Failed to update macro goals');
            }

            btnUpdateTargetMacros.textContent = '‚úÖ Saved!';
            setTimeout(() => {
              targetMacrosModal.classList.remove('show');
              btnUpdateTargetMacros.textContent = 'Update';
              btnUpdateTargetMacros.disabled = false;
              // Reload the Grocy Home to show updated goals
              loadGrocyHome();
            }, 1000);
          } catch (err) {
            console.error('Error updating macro goals:', err);
            alert('Failed to update macro goals');
            btnUpdateTargetMacros.textContent = 'Update';
            btnUpdateTargetMacros.disabled = false;
          }
        });

        // Close modal when clicking outside
        targetMacrosModal.addEventListener('click', (e) => {
          if (e.target === targetMacrosModal) {
            targetMacrosModal.classList.remove('show');
          }
        });
      }

      // Open missing Walmart links/prices (next 5)
      const btnOpenMissingWalmart = document.getElementById('btnOpenMissingWalmart');
      let missingWalmartOffset = 0; // Track pagination offset
      
      if (btnOpenMissingWalmart) {
        btnOpenMissingWalmart.addEventListener('click', async () => {
          try {
            btnOpenMissingWalmart.disabled = true;
            btnOpenMissingWalmart.textContent = '‚è≥ Loading...';
            
            const res = await fetch(`./api/missing-walmart?limit=5&offset=${missingWalmartOffset}`);
            const data = await res.json();
            
            if (!res.ok || data.error) {
              throw new Error(data.error || 'Failed to fetch missing walmart items');
            }
            
            if (!data.items || data.items.length === 0) {
              alert('No more items with missing links or prices!');
              missingWalmartOffset = 0; // Reset offset
              btnOpenMissingWalmart.textContent = 'üîç Open Next 5 Missing Links/Prices';
              btnOpenMissingWalmart.disabled = false;
              return;
            }
            
            // Open each search URL in a new tab with a small delay
            for (let i = 0; i < data.items.length; i++) {
              const item = data.items[i];
              window.open(item.url, '_blank');
              
              // Small delay between opens (except for last item)
              if (i < data.items.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 150));
              }
            }
            
            // Update offset for next batch
            missingWalmartOffset += data.items.length;
            
            // Show success message with details
            const linkCount = data.items.filter(item => item.missing_link).length;
            const priceCount = data.items.filter(item => item.missing_price).length;
            let msg = `‚úÖ Opened ${data.items.length} links`;
            if (linkCount > 0 && priceCount > 0) {
              msg += ` (${linkCount} missing links, ${priceCount} missing prices)`;
            } else if (linkCount > 0) {
              msg += ` (missing links)`;
            } else if (priceCount > 0) {
              msg += ` (missing prices)`;
            }
            
            if (data.has_more) {
              msg += ` ‚Ä¢ ${data.total - missingWalmartOffset} more remaining`;
            } else {
              msg += ' ‚Ä¢ No more remaining';
              missingWalmartOffset = 0; // Reset for next time
            }
            
            btnOpenMissingWalmart.textContent = msg;
            setTimeout(() => {
              btnOpenMissingWalmart.textContent = data.has_more 
                ? 'üîç Open Next 5 Missing Links/Prices'
                : 'üîç Open Next 5 Missing Links/Prices (Start Over)';
            }, 3000);
          } catch (err) {
            console.error('Error opening missing walmart links:', err);
            alert('Failed to open missing walmart links: ' + err.message);
            btnOpenMissingWalmart.textContent = 'üîç Open Next 5 Missing Links/Prices';
          } finally {
            btnOpenMissingWalmart.disabled = false;
          }
        });
      }

      // Recent Days functionality
      let currentRecentDaysPage = 0;
      const recentDaysListEl = document.getElementById('recentDaysList');
      const btnPrevPage = document.getElementById('btnPrevPage');
      const btnNextPage = document.getElementById('btnNextPage');
      const pageInfo = document.getElementById('pageInfo');

      async function fetchRecentDays(page) {
        const res = await fetch(`./api/macros/recent-days?page=${page}&limit=4`);
        return await res.json();
      }

      async function loadRecentDays(page) {
        try {
          const data = await fetchRecentDays(page);
          currentRecentDaysPage = data.current_page || 0;
          
          // Clear existing days
          recentDaysListEl.innerHTML = '';
          
          // Render each day as an expandable card
          if (data.days && data.days.length > 0) {
            data.days.forEach((dayData) => {
              const dayCard = createDayCard(dayData);
              recentDaysListEl.appendChild(dayCard);
            });
          } else {
            recentDaysListEl.innerHTML = '<p style="color: #666; padding: 12px;">No recent days with activity</p>';
          }
          
          // Update pagination controls
          pageInfo.textContent = `Page ${currentRecentDaysPage + 1}`;
          btnPrevPage.disabled = currentRecentDaysPage <= 0;
          btnNextPage.disabled = currentRecentDaysPage >= (data.total_pages - 1);
        } catch (err) {
          console.error('Error loading recent days:', err);
          recentDaysListEl.innerHTML = '<p style="color: red; padding: 12px;">Failed to load recent days</p>';
        }
      }

      function createDayCard(dayData) {
        const card = document.createElement('div');
        card.className = 'dayCard';

        const consumed = dayData.consumed || {};
        const goal = dayData.goal || {};
        const entries = consumed.entries || [];

        // Card header with summary
        const header = document.createElement('div');
        header.className = 'dayCardHeader';
        header.innerHTML = `
          <span>${dayData.day}</span>
          <span>${consumed.calories || 0} / ${goal.calories || 0} cal</span>
        `;

        // Expanded content (hidden by default)
        const expanded = document.createElement('div');
        expanded.className = 'dayCardExpanded';

        // Macro summary
        const macroSummary = document.createElement('div');
        macroSummary.style.marginBottom = '12px';
        macroSummary.innerHTML = `
          <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 8px;">
            <div><strong>Carbs:</strong> ${(consumed.carbs || 0).toFixed(1)}g / ${(goal.carbs || 0).toFixed(1)}g</div>
            <div><strong>Fats:</strong> ${(consumed.fats || 0).toFixed(1)}g / ${(goal.fats || 0).toFixed(1)}g</div>
            <div><strong>Protein:</strong> ${(consumed.protein || 0).toFixed(1)}g / ${(goal.protein || 0).toFixed(1)}g</div>
          </div>
        `;
        expanded.appendChild(macroSummary);
        
        // Entries list
        if (entries.length > 0) {
          const entriesTitle = document.createElement('div');
          entriesTitle.style.fontWeight = '600';
          entriesTitle.style.marginBottom = '8px';
          entriesTitle.textContent = 'Consumed Items:';
          expanded.appendChild(entriesTitle);
          
          entries.forEach((entry) => {
            const entryDiv = document.createElement('div');
            entryDiv.className = 'entryItem';
            entryDiv.innerHTML = `
              <div class="entryName">${entry.name}</div>
              <div class="entryMacros">${entry.calories || 0}cal ‚Ä¢ ${(entry.carbs || 0).toFixed(1)}g C ‚Ä¢ ${(entry.fats || 0).toFixed(1)}g F ‚Ä¢ ${(entry.protein || 0).toFixed(1)}g P</div>
            `;
            expanded.appendChild(entryDiv);
          });
        } else {
          const noEntries = document.createElement('p');
          noEntries.style.color = '#666';
          noEntries.style.fontSize = '13px';
          noEntries.textContent = 'No consumed items for this day';
          expanded.appendChild(noEntries);
        }
        
        card.appendChild(header);
        card.appendChild(expanded);
        
        // Toggle expand on click
        header.addEventListener('click', () => {
          card.classList.toggle('expanded');
        });
        
        return card;
      }

      // Pagination button handlers
      btnPrevPage.addEventListener('click', () => {
        if (currentRecentDaysPage > 0) {
          loadRecentDays(currentRecentDaysPage - 1);
        }
      });

      btnNextPage.addEventListener('click', () => {
        loadRecentDays(currentRecentDaysPage + 1);
      });

      // =====================
      // Walmart Manager Functions
      // =====================
      
      const btnFetchMissingLinks = document.getElementById('btnFetchMissingLinks');
      const btnCompleteLinkUpdates = document.getElementById('btnCompleteLinkUpdates');
      const btnStartPriceUpdate = document.getElementById('btnStartPriceUpdate');
      const productOptionsContainer = document.getElementById('productOptionsContainer');
      const missingLinksCount = document.getElementById('missingLinksCount');
      const missingPricesCount = document.getElementById('missingPricesCount');
      const priceUpdateProgress = document.getElementById('priceUpdateProgress');
      const priceProgressBar = document.getElementById('priceProgressBar');
      const priceProgressText = document.getElementById('priceProgressText');
      const priceErrorList = document.getElementById('priceErrorList');
      const manualPriceSection = document.getElementById('manualPriceSection');
      const manualPriceList = document.getElementById('manualPriceList');
      const btnCompleteManualPrices = document.getElementById('btnCompleteManualPrices');
      
      let loadedProducts = [];
      let selectedOptions = {}; // { product_id: { url, price } }
      let currentPriceJobId = null;
      let isOperationRunning = false; // Track if any operation is running
      let nonWalmartItems = []; // Items that need manual price entry
      
      async function loadWalmartManager() {
        try {
          await loadMissingLinksCount();
          await loadMissingPricesCount();
        } catch (err) {
          console.error('Error loading Walmart Manager:', err);
        }
      }
      
      function updateOperationButtons() {
        // Disable both buttons when any operation is running
        btnFetchMissingLinks.disabled = isOperationRunning;
        btnStartPriceUpdate.disabled = isOperationRunning || currentPriceJobId !== null;
        
        // Gray out buttons when disabled
        if (isOperationRunning) {
          btnFetchMissingLinks.style.opacity = '0.5';
          btnFetchMissingLinks.style.cursor = 'not-allowed';
          btnStartPriceUpdate.style.opacity = '0.5';
          btnStartPriceUpdate.style.cursor = 'not-allowed';
        } else {
          btnFetchMissingLinks.style.opacity = '';
          btnFetchMissingLinks.style.cursor = '';
          if (currentPriceJobId === null) {
            btnStartPriceUpdate.style.opacity = '';
            btnStartPriceUpdate.style.cursor = '';
          }
        }
      }
      
      async function loadMissingLinksCount() {
        try {
          const res = await fetch('./api/walmart/missing-links-batch?limit=999');
          const data = await res.json();
          missingLinksCount.textContent = data.total || 0;
        } catch (err) {
          console.error('Error loading missing links count:', err);
          missingLinksCount.textContent = 'Error';
        }
      }
      
      async function loadMissingPricesCount() {
        try {
          const res = await fetch('./api/status/counts');
          const data = await res.json();
          // Count only items with link but missing price
          const counts = await fetch('./api/walmart/missing-links-batch?limit=999');
          const linksData = await counts.json();
          const totalMissingLinks = linksData.total || 0;
          const totalMissingPrices = data.missing_prices || 0;
          // Missing prices with links = total missing prices - total missing links
          const missingPricesWithLinks = Math.max(0, totalMissingPrices - totalMissingLinks);
          missingPricesCount.textContent = missingPricesWithLinks;
        } catch (err) {
          console.error('Error loading missing prices count:', err);
          missingPricesCount.textContent = 'Error';
        }
      }
      
      async function fetchAndDisplayMissingLinks() {
        try {
          isOperationRunning = true;
          updateOperationButtons();
          btnFetchMissingLinks.textContent = 'Loading...';
          productOptionsContainer.innerHTML = '';
          selectedOptions = {};
          
          // Fetch first 5 products with missing links
          const res = await fetch('./api/walmart/missing-links-batch?limit=5');
          const data = await res.json();
          
          if (!data.products || data.products.length === 0) {
            productOptionsContainer.innerHTML = '<div style="padding:20px;text-align:center;color:#666;">No products with missing links found!</div>';
            btnFetchMissingLinks.textContent = 'Load Next 5 Products';
            isOperationRunning = false;
            updateOperationButtons();
            return;
          }
          
          loadedProducts = data.products;
          
          // Create placeholder cards for each product
          loadedProducts.forEach(product => {
            const productCard = document.createElement('div');
            productCard.className = 'productCard';
            const searchUrl = `https://www.walmart.com/search?q=${encodeURIComponent(product.name)}`;
            productCard.innerHTML = `
              <div class="productName">
                <span style="flex: 1;">${product.name}</span>
                <a href="${searchUrl}" target="_blank" class="searchLink">üîç Search</a>
                <div class="notWalmartCheckbox">
                  <input type="checkbox" id="notWalmart_${product.id}" class="notWalmartCheck" data-product-id="${product.id}">
                  <label for="notWalmart_${product.id}">Not a Walmart Item</label>
                </div>
              </div>
              <div class="loadingText">Loading options...</div>
              <div class="customLinkBox">
                <label>Or paste a custom Walmart link:</label>
                <input type="text" class="customLinkInput" placeholder="https://www.walmart.com/ip/..." data-product-id="${product.id}">
              </div>
            `;
            productCard.setAttribute('data-product-id', product.id);
            productOptionsContainer.appendChild(productCard);
            
            // Add event listener to custom link input to show/hide complete button
            const customInput = productCard.querySelector('.customLinkInput');
            customInput.addEventListener('input', updateCompleteButton);
            
            // Add event listener to checkbox to update complete button
            const notWalmartCheck = productCard.querySelector('.notWalmartCheck');
            notWalmartCheck.addEventListener('change', updateCompleteButton);
          });
          
          // Scrape search results in parallel via the backend worker pool (5 workers)
          btnFetchMissingLinks.textContent = 'Scraping with 5 workers...';

          const scrapeRes = await fetch('./api/walmart/scrape-search-batch', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ products: loadedProducts })
          });

          const scrapeData = await scrapeRes.json();

          if (!scrapeRes.ok) {
            throw new Error(scrapeData.error || 'Failed to scrape Walmart search results');
          }

          const resultsById = new Map();
          (scrapeData.results || []).forEach(result => {
            const pid = parseInt(result.product_id);
            if (pid) {
              resultsById.set(pid, result);
            }
          });

          if (Array.isArray(scrapeData.errors) && scrapeData.errors.length > 0) {
            console.warn('Some Walmart scrape jobs failed:', scrapeData.errors);
          }

          loadedProducts.forEach(product => {
            const productCard = productOptionsContainer.querySelector(`[data-product-id="${product.id}"]`);
            if (!productCard) return;

            const loadingText = productCard.querySelector('.loadingText');
            const scrapeResult = resultsById.get(product.id);

            if (!scrapeResult) {
              if (loadingText) loadingText.textContent = 'No results returned';
              return;
            }

            if (scrapeResult.error) {
              if (loadingText) loadingText.textContent = `Error: ${scrapeResult.error}`;
              return;
            }

            const options = Array.isArray(scrapeResult.options) ? scrapeResult.options : [];
            const metadata = scrapeResult.metadata || null;

            // Check if location is wrong (compare requested vs actual store_id)
            const requestedStoreId = metadata?.search_parameters?.store_id;
            const actualStoreId = metadata?.search_information?.location?.store_id;
            const hasLocationWarning = requestedStoreId && actualStoreId && requestedStoreId !== actualStoreId;

            if (options.length === 0) {
              if (loadingText) loadingText.textContent = 'No options found';
              return;
            }

            if (loadingText) loadingText.remove();

            // Add location warning if needed
            if (hasLocationWarning) {
              const warningDiv = document.createElement('div');
              warningDiv.className = 'locationWarning';
              warningDiv.innerHTML = '‚ö†Ô∏è Wrong location returned - use search button to find product manually';
              productCard.insertBefore(warningDiv, productCard.querySelector('.customLinkBox'));
            }

            const optionsGrid = document.createElement('div');
            optionsGrid.className = 'optionsGrid';

            options.forEach((option, index) => {
              const optionCard = document.createElement('div');
              optionCard.className = 'optionCard';
              optionCard.setAttribute('data-option-index', index);

              optionCard.innerHTML = `
                <div class="radioCircle"></div>
                <img class="optionImage" src="${option.image_url || 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'100\' height=\'100\'%3E%3Crect fill=\'%23ddd\' width=\'100\' height=\'100\'/%3E%3C/svg%3E'}" alt="${option.name || 'Product'}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'100\' height=\'100\'%3E%3Crect fill=\'%23ddd\' width=\'100\' height=\'100\'/%3E%3C/svg%3E'">
                <div class="optionName">${option.name || 'Unknown Product'}</div>
                <a href="${option.product_url || '#'}" target="_blank" class="optionPrice" onclick="event.stopPropagation();">${option.price || 'Price N/A'}</a>
              `;

              optionCard.addEventListener('click', () => {
                // Deselect all options for this product
                optionsGrid.querySelectorAll('.optionCard').forEach(card => card.classList.remove('selected'));
                // Select this option
                optionCard.classList.add('selected');
                // Store selection with cleaned URL
                selectedOptions[product.id] = {
                  url: cleanWalmartUrl(option.product_url),
                  price: option.price
                };
                // Show complete button if any selections exist
                updateCompleteButton();
              });

              optionsGrid.appendChild(optionCard);
            });

            productCard.appendChild(optionsGrid);
          });
          
          btnFetchMissingLinks.textContent = 'Load Next 5 Products';
          isOperationRunning = false;
          updateOperationButtons();
          
        } catch (err) {
          console.error('Error fetching missing links:', err);
          alert('Failed to load missing links: ' + err.message);
          btnFetchMissingLinks.textContent = 'Load Next 5 Products';
          isOperationRunning = false;
          updateOperationButtons();
        }
      }
      
      function cleanWalmartUrl(url) {
        try {
          // Extract just the product ID part of the URL
          // Format: https://www.walmart.com/ip/{product-name}/{product-id}
          const match = url.match(/^(https?:\/\/(?:www\.)?walmart\.com\/ip\/[^\/]+\/\d+)/);
          if (match) {
            return match[1];
          }
          return url; // Return original if no match
        } catch (e) {
          return url;
        }
      }
      
      function updateCompleteButton() {
        // Check if there are any selections, custom links, or not_walmart checkboxes
        const hasSelections = Object.keys(selectedOptions).length > 0;
        const customLinkInputs = document.querySelectorAll('.customLinkInput');
        const hasCustomLinks = Array.from(customLinkInputs).some(input => input.value.trim());
        const notWalmartChecks = document.querySelectorAll('.notWalmartCheck:checked');
        const hasNotWalmartChecks = notWalmartChecks.length > 0;
        
        btnCompleteLinkUpdates.style.display = (hasSelections || hasCustomLinks || hasNotWalmartChecks) ? 'block' : 'none';
      }
      
      async function completeLinkUpdates() {
        // Collect not_walmart checkboxes
        const notWalmartChecks = document.querySelectorAll('.notWalmartCheck:checked');
        const notWalmartIds = Array.from(notWalmartChecks).map(check => parseInt(check.getAttribute('data-product-id')));
        
        // Collect custom links (exclude items marked as not_walmart)
        const customLinkInputs = document.querySelectorAll('.customLinkInput');
        const customLinks = [];
        customLinkInputs.forEach(input => {
          const link = input.value.trim();
          const productId = parseInt(input.getAttribute('data-product-id'));
          if (link && productId && !notWalmartIds.includes(productId)) {
            // Clean the URL to remove query parameters
            const cleanLink = cleanWalmartUrl(link);
            customLinks.push({ product_id: productId, walmart_link: cleanLink });
          }
        });
        
        // Filter selected options to exclude items marked as not_walmart
        const filteredSelectedOptions = {};
        Object.keys(selectedOptions).forEach(productId => {
          const pid = parseInt(productId);
          if (!notWalmartIds.includes(pid)) {
            filteredSelectedOptions[productId] = selectedOptions[productId];
          }
        });
        
        // Check if there are any updates to process
        const hasSelections = Object.keys(filteredSelectedOptions).length > 0;
        const hasCustomLinks = customLinks.length > 0;
        const hasNotWalmartFlags = notWalmartIds.length > 0;
        
        if (!hasSelections && !hasCustomLinks && !hasNotWalmartFlags) {
          alert('Please select at least one option, paste a custom link, or mark items as not Walmart');
          return;
        }
        
        try {
          btnCompleteLinkUpdates.disabled = true;
          btnCompleteLinkUpdates.textContent = 'Updating...';
          
          // Mark not_walmart items first
          if (hasNotWalmartFlags) {
            btnCompleteLinkUpdates.textContent = `Marking ${notWalmartIds.length} as not Walmart...`;
            try {
              const notWalmartRes = await fetch('./api/walmart/mark-not-walmart', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ product_ids: notWalmartIds })
              });
              
              if (!notWalmartRes.ok) {
                const errData = await notWalmartRes.json();
                console.error('Failed to mark some items as not Walmart:', errData);
              }
            } catch (err) {
              console.error('Error marking items as not Walmart:', err);
            }
          }
          
          // Prepare updates array from selections (excluding not_walmart items)
          const updates = Object.keys(filteredSelectedOptions).map(productId => ({
            product_id: parseInt(productId),
            walmart_link: filteredSelectedOptions[productId].url,
            price: filteredSelectedOptions[productId].price
          }));
          
          // Process custom links - scrape prices first
          if (customLinks.length > 0) {
            btnCompleteLinkUpdates.textContent = `Scraping ${customLinks.length} custom link${customLinks.length > 1 ? 's' : ''}...`;
            
            for (const customLink of customLinks) {
              try {
                // Scrape the custom link for price
                const scrapeRes = await fetch('./api/walmart/scrape-product', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ url: customLink.walmart_link })
                });
                
                const scrapeData = await scrapeRes.json();
                
                if (scrapeRes.ok && scrapeData.price) {
                  // Add to updates with scraped price
                  updates.push({
                    product_id: customLink.product_id,
                    walmart_link: customLink.walmart_link,
                    price: scrapeData.price
                  });
                } else {
                  // Add without price if scraping failed
                  console.warn(`Failed to scrape price for custom link: ${customLink.walmart_link}`);
                  updates.push({
                    product_id: customLink.product_id,
                    walmart_link: customLink.walmart_link,
                    price: null
                  });
                }
              } catch (err) {
                console.error(`Error scraping custom link: ${err.message}`);
                // Still add the link even if scraping failed
                updates.push({
                  product_id: customLink.product_id,
                  walmart_link: customLink.walmart_link,
                  price: null
                });
              }
            }
          }
          
          // Send update request
          btnCompleteLinkUpdates.textContent = 'Saving to Grocy...';
          const res = await fetch('./api/walmart/update-selections', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ updates })
          });
          
          const data = await res.json();
          
          if (!res.ok) {
            throw new Error(data.error || 'Update failed');
          }
          
          // Show success
          let successMsg = '';
          if (updates.length > 0 && hasNotWalmartFlags) {
            successMsg = `‚úì Updated ${updates.length} product${updates.length > 1 ? 's' : ''} & marked ${notWalmartIds.length} as not Walmart!`;
          } else if (updates.length > 0) {
            successMsg = `‚úì Updated ${updates.length} product${updates.length > 1 ? 's' : ''}!`;
          } else if (hasNotWalmartFlags) {
            successMsg = `‚úì Marked ${notWalmartIds.length} product${notWalmartIds.length > 1 ? 's' : ''} as not Walmart!`;
          }
          btnCompleteLinkUpdates.textContent = successMsg;
          
          // Clear the display after 2 seconds and reload counts
          setTimeout(() => {
            productOptionsContainer.innerHTML = '';
            selectedOptions = {};
            loadedProducts = [];
            btnCompleteLinkUpdates.style.display = 'none';
            btnCompleteLinkUpdates.textContent = 'Complete & Update Selected';
            btnCompleteLinkUpdates.disabled = false;
            loadMissingLinksCount();
            loadMissingPricesCount();
          }, 2000);
          
        } catch (err) {
          console.error('Error completing link updates:', err);
          alert('Failed to update: ' + err.message);
          btnCompleteLinkUpdates.textContent = 'Complete & Update Selected';
          btnCompleteLinkUpdates.disabled = false;
        }
      }
      
      async function loadNonWalmartItems() {
        try {
          const res = await fetch('./api/walmart/non-walmart-items');
          const data = await res.json();
          
          if (!res.ok) {
            throw new Error(data.error || 'Failed to load non-Walmart items');
          }
          
          nonWalmartItems = data.items || [];
          
          if (nonWalmartItems.length > 0) {
            // Display manual price entry UI
            manualPriceSection.style.display = 'block';
            manualPriceList.innerHTML = '';
            
            nonWalmartItems.forEach(item => {
              const itemDiv = document.createElement('div');
              itemDiv.style.display = 'grid';
              itemDiv.style.gridTemplateColumns = '2fr 1fr';
              itemDiv.style.gap = '12px';
              itemDiv.style.alignItems = 'center';
              itemDiv.style.padding = '12px';
              itemDiv.style.background = '#fff';
              itemDiv.style.border = '1px solid #ddd';
              itemDiv.style.borderRadius = '6px';
              
              const nameSpan = document.createElement('span');
              nameSpan.textContent = item.name;
              nameSpan.style.fontWeight = '500';
              
              const priceInput = document.createElement('input');
              priceInput.type = 'text';
              priceInput.placeholder = '$0.00';
              priceInput.setAttribute('data-product-id', item.id);
              priceInput.className = 'manualPriceInput';
              priceInput.style.padding = '8px';
              priceInput.style.border = '1px solid #ccc';
              priceInput.style.borderRadius = '4px';
              priceInput.addEventListener('input', updateManualPriceButton);
              
              itemDiv.appendChild(nameSpan);
              itemDiv.appendChild(priceInput);
              manualPriceList.appendChild(itemDiv);
            });
            
            updateManualPriceButton();
          } else {
            manualPriceSection.style.display = 'none';
          }
        } catch (err) {
          console.error('Error loading non-Walmart items:', err);
        }
      }
      
      function updateManualPriceButton() {
        const inputs = document.querySelectorAll('.manualPriceInput');
        const hasAnyPrice = Array.from(inputs).some(input => input.value.trim());
        btnCompleteManualPrices.style.display = hasAnyPrice ? 'block' : 'none';
      }
      
      async function completeManualPrices() {
        try {
          btnCompleteManualPrices.disabled = true;
          btnCompleteManualPrices.textContent = 'Updating...';
          
          const inputs = document.querySelectorAll('.manualPriceInput');
          const updates = [];
          
          inputs.forEach(input => {
            const price = input.value.trim();
            const productId = parseInt(input.getAttribute('data-product-id'));
            if (price && productId) {
              updates.push({ product_id: productId, price: price });
            }
          });
          
          if (updates.length === 0) {
            alert('Please enter at least one price');
            btnCompleteManualPrices.disabled = false;
            btnCompleteManualPrices.textContent = 'Complete Manual Prices';
            return;
          }
          
          const res = await fetch('./api/walmart/update-manual-prices', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ updates })
          });
          
          const data = await res.json();
          
          if (!res.ok) {
            throw new Error(data.error || 'Failed to update prices');
          }
          
          btnCompleteManualPrices.textContent = `‚úì Updated ${updates.length} price${updates.length > 1 ? 's' : ''}!`;
          
          setTimeout(() => {
            manualPriceSection.style.display = 'none';
            manualPriceList.innerHTML = '';
            btnCompleteManualPrices.style.display = 'none';
            btnCompleteManualPrices.textContent = 'Complete Manual Prices';
            btnCompleteManualPrices.disabled = false;
            loadMissingPricesCount();
          }, 2000);
          
        } catch (err) {
          console.error('Error completing manual prices:', err);
          alert('Failed to update manual prices: ' + err.message);
          btnCompleteManualPrices.textContent = 'Complete Manual Prices';
          btnCompleteManualPrices.disabled = false;
        }
      }
      
      async function startPriceUpdate() {
        try {
          isOperationRunning = true;
          updateOperationButtons();
          btnStartPriceUpdate.textContent = 'Starting...';
          priceUpdateProgress.style.display = 'none';
          priceErrorList.innerHTML = '';
          manualPriceSection.style.display = 'none';
          
          // Start both processes in parallel
          const [walmartRes, nonWalmartLoad] = await Promise.all([
            fetch('./api/walmart/start-price-update', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
            }),
            loadNonWalmartItems()
          ]);
          
          const data = await walmartRes.json();
          
          if (!walmartRes.ok) {
            throw new Error(data.error || 'Failed to start price update');
          }
          
          if (data.total === 0 && nonWalmartItems.length === 0) {
            alert('No products need price updates!');
            btnStartPriceUpdate.textContent = 'Start Price Update';
            isOperationRunning = false;
            updateOperationButtons();
            return;
          }
          
          if (data.total > 0) {
            currentPriceJobId = data.job_id;
            
            // Show progress UI
            priceUpdateProgress.style.display = 'block';
            priceProgressBar.style.width = '0%';
            priceProgressText.textContent = `0 / ${data.total}`;
            
            // Poll for status
            pollPriceUpdateStatus();
          } else {
            // No Walmart items to update, just show manual entry
            btnStartPriceUpdate.textContent = 'Start Price Update';
            isOperationRunning = false;
            updateOperationButtons();
          }
          
        } catch (err) {
          console.error('Error starting price update:', err);
          alert('Failed to start price update: ' + err.message);
          btnStartPriceUpdate.textContent = 'Start Price Update';
          isOperationRunning = false;
          updateOperationButtons();
        }
      }
      
      async function pollPriceUpdateStatus() {
        if (!currentPriceJobId) return;
        
        try {
          const res = await fetch(`./api/walmart/price-update-status/${currentPriceJobId}`);
          const data = await res.json();
          
          if (!res.ok) {
            throw new Error(data.error || 'Failed to get status');
          }
          
          // Update progress
          const percent = data.total > 0 ? (data.completed / data.total * 100) : 0;
          priceProgressBar.style.width = percent + '%';
          priceProgressText.textContent = `${data.completed} / ${data.total}`;
          
          // Update errors if any
          if (data.errors && data.errors.length > 0) {
            priceErrorList.innerHTML = data.errors.map(err => 
              `<div class="errorItem">${err.product_name || 'Unknown'}: ${err.error}</div>`
            ).join('');
          }
          
          // Check if done
          if (data.status === 'completed' || data.status === 'error') {
            btnStartPriceUpdate.textContent = data.status === 'completed' 
              ? `‚úì Updated ${data.completed} prices!`
              : '‚ùå Update failed';
            
            setTimeout(() => {
              btnStartPriceUpdate.textContent = 'Start Price Update';
              isOperationRunning = false;
              currentPriceJobId = null;
              updateOperationButtons();
              loadMissingPricesCount();
            }, 3000);
          } else {
            // Continue polling
            setTimeout(pollPriceUpdateStatus, 1000);
          }
          
        } catch (err) {
          console.error('Error polling price update status:', err);
          btnStartPriceUpdate.textContent = 'Start Price Update';
          isOperationRunning = false;
          currentPriceJobId = null;
          updateOperationButtons();
        }
      }
      
      // Wire up Walmart Manager buttons
      btnFetchMissingLinks.addEventListener('click', fetchAndDisplayMissingLinks);
      btnCompleteLinkUpdates.addEventListener('click', completeLinkUpdates);
      btnStartPriceUpdate.addEventListener('click', startPriceUpdate);
      btnCompleteManualPrices.addEventListener('click', completeManualPrices);

      // removed MAX_RED limit on new items
      let scanOp = 'add'; // 'add' => Purchase, 'remove' => Consume, 'shopping' => Add to Shopping List
      let items = []; // { key, barcode, product_id|null, name, servings, isRed, active, lastSavedServings|null, pendingSave:false, mealPlanEntryId:null, isMealPlanItem:false, lastConsumedAmount|null, operation, unitUsed, stockBefore, stockAfter, isNew, servingsPerContainer, amountAdded }
      let activeKey = null;
      let overwriteOnNextDigit = false;
      let saveTimer = null;
      let currentlySaving = new Set(); // Track items currently being saved
      
      // Nutrition editor state
      let nutritionEditorVisible = false;
      let activeNutritionField = null;
      let nutritionDataCache = {}; // Keyed by item.key
      let originalMacros = {}; // Track original carbs/fats/protein for proportional scaling

      // Helper: Fetch current stock level in containers
      async function fetchStockLevel(productId) {
        try {
          const res = await fetch(`./api/proxy/stock/products/${productId}`);
          if (!res.ok) {
            console.error('Stock fetch failed:', res.status, res.statusText);
            return null;
          }
          const data = await res.json();
          // Grocy returns stock_amount or amount
          const stock = Number.isFinite(data.stock_amount) ? data.stock_amount : (Number.isFinite(data.amount) ? data.amount : null);
          console.log(`Fetched stock for product ${productId}:`, stock, 'from data:', data);
          return stock;
        } catch (err) {
          console.error('Failed to fetch stock level for product', productId, ':', err);
          return null;
        }
      }

      // Helper: Convert servings to containers
      function convertServingsToContainers(servings, servingsPerContainer) {
        const spc = Number.isFinite(servingsPerContainer) && servingsPerContainer > 0 ? servingsPerContainer : 1;
        return servings / spc;
      }

      // Helper: Convert containers to servings
      function convertContainersToServings(containers, servingsPerContainer) {
        const spc = Number.isFinite(servingsPerContainer) && servingsPerContainer > 0 ? servingsPerContainer : 1;
        return containers * spc;
      }

      // Update screen units display based on mode and unit toggle
      function updateScreenUnits() {
        if (scanOp === 'add') {
          screenUnits.textContent = 'containers';
          unitMode = 'containers';
        } else if (scanOp === 'remove') {
          screenUnits.textContent = unitMode;
        } else if (scanOp === 'shopping') {
          screenUnits.textContent = 'containers';
          unitMode = 'containers';
        }
        
        // Update button text
        if (unitMode === 'servings') {
          btnUnitToggle.textContent = 'Servings';
        } else {
          btnUnitToggle.textContent = 'Containers';
        }
      }
      
      // ===== NUTRITION EDITOR FUNCTIONS =====
      
      async function showNutritionEditor(item) {
        nutritionEditorVisible = true;
        document.getElementById('standardScreen').style.display = 'none';
        document.getElementById('nutritionEditor').style.display = 'block';
        
        // Fetch product data
        try {
          const ufRes = await fetch(`./api/proxy/userfields/products/${item.product_id}`);
          const userfields = await ufRes.json();
          
          // Populate fields (no name input)
          const servingsInput = document.getElementById('nutritionServings');
          const caloriesInput = document.getElementById('nutritionCalories');
          const carbsInput = document.getElementById('nutritionCarbs');
          const fatsInput = document.getElementById('nutritionFats');
          const proteinInput = document.getElementById('nutritionProtein');
          
          const servings = Number(userfields['Number of Servings'] || userfields['num_servings'] || item.servingsPerContainer || 1);
          servingsInput.value = String(servings);
          
          const carbs = Number(userfields['Carbs'] || 0);
          const fats = Number(userfields['Fats'] || 0);
          const protein = Number(userfields['Protein'] || 0);
          const calories = Number(userfields['Calories per Serving'] || userfields['Calories_Per_Serving'] || 0);
          
          carbsInput.value = String(carbs);
          fatsInput.value = String(fats);
          proteinInput.value = String(protein);
          caloriesInput.value = String(calories || Math.round(4 * carbs + 4 * protein + 9 * fats));
          
          // Store original macros for scaling
          originalMacros[item.key] = { carbs, fats, protein, calories: Number(caloriesInput.value) };
          
          // Setup focus listeners
          [servingsInput, caloriesInput, carbsInput, fatsInput, proteinInput].forEach(input => {
            input.addEventListener('focus', () => {
              activeNutritionField = input.id;
              document.querySelectorAll('.nutritionField').forEach(f => f.classList.remove('focused'));
              input.parentElement.classList.add('focused');
            });
            
            input.addEventListener('input', () => {
              onNutritionInput(input.id, item);
            });
          });
          
          // Set initial focus to servings field
          setTimeout(() => {
            servingsInput.focus();
            servingsInput.select();
          }, 100);
          
        } catch (e) {
          console.error('Failed to load nutrition data:', e);
        }
      }
      
      function hideNutritionEditor() {
        nutritionEditorVisible = false;
        document.getElementById('standardScreen').style.display = 'flex';
        document.getElementById('nutritionEditor').style.display = 'none';
        activeNutritionField = null;
        document.querySelectorAll('.nutritionField').forEach(f => f.classList.remove('focused'));
      }
      
      function onNutritionInput(fieldId, item) {
        if (!item) return;
        
        const caloriesInput = document.getElementById('nutritionCalories');
        const carbsInput = document.getElementById('nutritionCarbs');
        const fatsInput = document.getElementById('nutritionFats');
        const proteinInput = document.getElementById('nutritionProtein');
        
        const origMacros = originalMacros[item.key] || {};
        
        if (fieldId === 'nutritionCalories') {
          // User edited calories - scale macros proportionally
          const newCalories = Number(caloriesInput.value) || 0;
          const oldCalories = origMacros.calories || 1;
          
          if (oldCalories > 0 && newCalories > 0) {
            const scalingFactor = newCalories / oldCalories;
            
            carbsInput.value = String(Math.round((origMacros.carbs || 0) * scalingFactor * 10) / 10);
            fatsInput.value = String(Math.round((origMacros.fats || 0) * scalingFactor * 10) / 10);
            proteinInput.value = String(Math.round((origMacros.protein || 0) * scalingFactor * 10) / 10);
            
            // Update original macros with new values
            originalMacros[item.key] = {
              carbs: Number(carbsInput.value),
              fats: Number(fatsInput.value),
              protein: Number(proteinInput.value),
              calories: newCalories
            };
          }
        } else if (fieldId === 'nutritionCarbs' || fieldId === 'nutritionFats' || fieldId === 'nutritionProtein') {
          // User edited macro - recalculate calories
          const carbs = Number(carbsInput.value) || 0;
          const fats = Number(fatsInput.value) || 0;
          const protein = Number(proteinInput.value) || 0;
          
          const calculatedCalories = Math.round(4 * carbs + 4 * protein + 9 * fats);
          caloriesInput.value = String(calculatedCalories);
          
          // Update original macros
          originalMacros[item.key] = { carbs, fats, protein, calories: calculatedCalories };
        }
        
        // Schedule save
        if (saveTimer) clearTimeout(saveTimer);
        saveTimer = setTimeout(() => {
          saveNutritionData(item);
        }, 300);
      }
      
      async function saveNutritionData(item) {
        if (!item || !Number.isFinite(Number(item.product_id))) return;
        
        const servingsInput = document.getElementById('nutritionServings');
        const caloriesInput = document.getElementById('nutritionCalories');
        const carbsInput = document.getElementById('nutritionCarbs');
        const fatsInput = document.getElementById('nutritionFats');
        const proteinInput = document.getElementById('nutritionProtein');
        
        const servings = Number(servingsInput.value) || 1;
        const calories = Number(caloriesInput.value) || 0;
        const carbs = Number(carbsInput.value) || 0;
        const fats = Number(fatsInput.value) || 0;
        const protein = Number(proteinInput.value) || 0;
        
        try {
          // Update userfields only (name stays in activeName display)
          await fetch(`./api/proxy/userfields/products/${item.product_id}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              'Calories per Serving': calories,
              'Carbs': carbs,
              'Fats': fats,
              'Protein': protein,
              'Number of Servings': servings
            })
          });
          
          // Update cached data
          item.servingsPerContainer = servings;
          nutritionDataCache[item.key] = { servings, calories, carbs, fats, protein };
          
          statusText.textContent = 'Nutrition data saved';
          setTimeout(() => { if (statusText.textContent === 'Nutrition data saved') statusText.textContent = ''; }, 1200);
          
          renderQueue();
        } catch (e) {
          console.error('Failed to save nutrition data:', e);
          statusText.textContent = 'Save error: ' + (e && e.message || e);
        }
      }

      // Update screen units display based on mode and unit toggle
      function updateScreenUnits() {
        if (scanOp === 'add') {
          screenUnits.textContent = 'containers';
          unitMode = 'containers';
        } else if (scanOp === 'remove') {
          screenUnits.textContent = unitMode;
        } else if (scanOp === 'shopping') {
          screenUnits.textContent = 'containers';
          unitMode = 'containers';
        }
        
        // Update button text
        if (unitMode === 'servings') {
          btnUnitToggle.textContent = 'Servings';
        } else {
          btnUnitToggle.textContent = 'Containers';
        }
      }

      // Toggle between servings and containers (only active in consume mode)
      async function toggleUnit() {
        if (scanOp !== 'remove') return;
        
        const activeItem = getActiveItem();
        if (!activeItem) return;
        
        // Fetch servings per container if not available
        if (!Number.isFinite(activeItem.servingsPerContainer)) {
          try {
            const res = await fetch(`./api/products/${activeItem.product_id}/servings`);
            const data = await res.json();
            activeItem.servingsPerContainer = Number.isFinite(data.servings) ? data.servings : 1;
          } catch {
            activeItem.servingsPerContainer = 1;
          }
        }
        
        const currentValue = Number(screen.value) || 0;
        let newValue;
        
        // Toggle unit mode
        if (unitMode === 'servings') {
          unitMode = 'containers';
          newValue = convertServingsToContainers(currentValue, activeItem.servingsPerContainer);
        } else {
          unitMode = 'servings';
          newValue = convertContainersToServings(currentValue, activeItem.servingsPerContainer);
        }
        
        // Update the active item's unit
        activeItem.unitUsed = unitMode;
        
        screen.value = String(Math.round(newValue * 100) / 100);
        updateScreenUnits();
        updateFromScreen();
      }

      function setMode(op) {
        scanOp = op;
        btnPurchase.classList.remove('active');
        btnConsume.classList.remove('active');
        btnAddToShopping.classList.remove('active');
        
        if (scanOp === 'add') {
          btnPurchase.classList.add('active');
          // Purchase mode: always containers
          unitMode = 'containers';
          btnUnitToggle.disabled = true;
        } else if (scanOp === 'remove') {
          btnConsume.classList.add('active');
          // Consume mode: enable unit toggle, set default based on meal plan
          btnUnitToggle.disabled = false;
          unitMode = mealPlanEnabled ? 'servings' : 'containers';
        } else if (scanOp === 'shopping') {
          btnAddToShopping.classList.add('active');
          // Shopping mode: always containers
          unitMode = 'containers';
          btnUnitToggle.disabled = true;
        }
        
        updateScreenUnits();
      }
      btnPurchase.addEventListener('click', () => setMode('add'));
      btnConsume.addEventListener('click', () => setMode('remove'));
      btnAddToShopping.addEventListener('click', () => setMode('shopping'));
      btnComplete.addEventListener('click', () => { 
        const activeItem = getActiveItem();
        if (activeItem) saveItemImmediate(activeItem);
        try { barcodeInput.focus(); } catch (_) {} 
      });
      if (btnLogAll && btnLogNew) {
        btnLogAll.addEventListener('click', () => { btnLogAll.classList.add('active'); btnLogNew.classList.remove('active'); renderQueue(); });
        btnLogNew.addEventListener('click', () => { btnLogNew.classList.add('active'); btnLogAll.classList.remove('active'); renderQueue(); });
      }

      function beepBad() {
        try {
          const AC = window.AudioContext || window.webkitAudioContext; if (!AC) return;
          const ctx = new AC();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'square'; osc.frequency.value = 330;
          gain.gain.value = 0.08;
          osc.connect(gain); gain.connect(ctx.destination);
          osc.start(); setTimeout(() => { osc.stop(); ctx.close(); }, 180);
        } catch (_) {}
      }

      function redCount() { return items.filter(x => x.isRed).length; }
      function showOnlyNew() { return btnLogNew && btnLogNew.classList.contains('active'); }

      function renderQueue() {
        queueEl.innerHTML = '';
        items.forEach((it) => {
          if (showOnlyNew() && !it.isRed) return;
          const div = document.createElement('div');
          const isActive = (it.key === activeKey);
          div.className = 'queueItem' + (it.isRed ? ' red' : '') + (isActive ? ' active' : '');
          if (isActive) div.style.outlineColor = 'var(--active)';
          
          // Row 1: Name
          const name = document.createElement('div');
          name.className = 'name';
          name.textContent = it.name || 'Unknown';
          
          // Row 2: Details based on operation
          const details = document.createElement('div');
          details.className = 'details';
          
          if (it.operation === 'add') {
            // Purchase mode
            const amount = Number.isFinite(it.servings) ? it.servings : 1;
            const unit = amount === 1 ? 'container' : 'containers';
            const servingsPerContainer = Number.isFinite(it.servingsPerContainer) ? it.servingsPerContainer : '?';
            
            // Show nutrition data if available
            const cached = nutritionDataCache[it.key];
            let detailText = `Purchased: ${amount} ${unit} | ${servingsPerContainer} servings/container`;
            if (cached && (cached.calories || cached.carbs || cached.fats || cached.protein)) {
              detailText += ` | Cal: ${cached.calories || 0} C: ${cached.carbs || 0}g F: ${cached.fats || 0}g P: ${cached.protein || 0}g`;
            } else {
              detailText += ` ‚úèÔ∏è Edit Nutrition`;
            }
            
            if (it.isNew) {
              const newBadge = document.createElement('span');
              newBadge.className = 'badge new';
              newBadge.textContent = 'NEW';
              details.textContent = detailText + ' ';
              details.appendChild(newBadge);
            } else {
              details.textContent = detailText;
            }
          } else if (it.operation === 'remove') {
            // Consume mode - show what was actually consumed
            // lastConsumedAmount is ALWAYS in servings (what was sent to backend)
            // We need to display it in a human-readable way
            
            const actualServings = Number.isFinite(it.lastConsumedAmount) ? it.lastConsumedAmount : 0;
            const servingsPerContainer = Number.isFinite(it.servingsPerContainer) ? it.servingsPerContainer : 1;
            
            let displayAmount, displayUnit;
            
            // If consumed a full container's worth of servings, show as containers
            if (actualServings > 0 && actualServings % servingsPerContainer === 0) {
              displayAmount = actualServings / servingsPerContainer;
              displayUnit = displayAmount === 1 ? 'container' : 'containers';
            } else if (actualServings > 0) {
              // Otherwise show as servings
              displayAmount = actualServings;
              displayUnit = actualServings === 1 ? 'serving' : 'servings';
            } else {
              // Nothing consumed yet
              displayAmount = 0;
              displayUnit = 'servings';
            }
            
            let detailText = `Consumed: ${displayAmount} ${displayUnit}`;
            
            // Add stock levels if available
            if (Number.isFinite(it.stockBefore) && Number.isFinite(it.stockAfter)) {
              const before = Math.round(it.stockBefore * 100) / 100;
              const after = Math.round(it.stockAfter * 100) / 100;
              detailText += ` | Stock: ${before} ‚Üí ${after}`;
            }
            
            // Add MP badge at end of details if meal plan item
            if (it.isMealPlanItem) {
              details.textContent = detailText + ' ';
              const mpBadge = document.createElement('span');
              mpBadge.className = 'badge mp';
              mpBadge.textContent = 'MP';
              details.appendChild(mpBadge);
            } else {
              details.textContent = detailText;
            }
          } else if (it.operation === 'shopping') {
            // Shopping mode - show diff (amount added/removed)
            const currentAmount = Number.isFinite(it.servings) ? it.servings : 1;
            const beforeAmount = Number.isFinite(it.lastSavedServings) ? it.lastSavedServings : 0;
            const diff = currentAmount - beforeAmount;
            const absDiff = Math.abs(diff);
            const unit = absDiff === 1 ? 'container' : 'containers';
            
            if (diff > 0) {
              details.textContent = `Added: ${absDiff} ${unit}`;
            } else if (diff < 0) {
              details.textContent = `Removed: ${absDiff} ${unit}`;
            } else {
              details.textContent = `0 containers`;
            }
          } else {
            // Fallback for items without operation set
            const amount = Number.isFinite(it.servings) ? it.servings : 1;
            details.textContent = `${amount}`;
          }
          
          // Right column
          const right = document.createElement('div');
          right.className = 'right';
          
          if (it.operation === 'add') {
            // Purchase: show new stock level
            if (Number.isFinite(it.stockAfter)) {
              right.textContent = `Stock: ${Math.round(it.stockAfter * 100) / 100}`;
            } else {
              right.textContent = 'Stock: ‚Äî';
            }
          } else if (it.operation === 'remove') {
            // Consume: show keypad amount in the current unit mode
            const amount = Number.isFinite(it.servings) ? it.servings : 1;
            const unitUsed = it.unitUsed || unitMode;
            const unit = amount === 1 ? unitUsed.slice(0, -1) : unitUsed; // singular/plural
            right.textContent = `${amount} ${unit}`;
          } else if (it.operation === 'shopping') {
            // Shopping: show total in shopping list
            const currentAmount = Number.isFinite(it.servings) ? it.servings : 1;
            const unit = currentAmount === 1 ? 'container' : 'containers';
            right.textContent = `${currentAmount} ${unit} in shopping list`;
          } else {
            // Fallback for legacy items without operation field
            // Try to show servings or leave empty
            if (Number.isFinite(it.servings) && it.servings > 0) {
              right.textContent = `${it.servings}`;
            }
          }
          
          div.appendChild(name);
          div.appendChild(details);
          div.appendChild(right);
          div.addEventListener('click', () => selectItem(it.key));
          queueEl.appendChild(div);
        });
      }

      function selectItem(key) {
        console.log(`[selectItem] Called with key=${key}, current activeKey=${activeKey}`);
        
        // Get the new item first
        const it = items.find(i => i.key === key);
        console.log(`[selectItem] Found item: key=${it?.key}, servings=${it?.servings}, lastConsumedAmount=${it?.lastConsumedAmount}`);
        
        // Save previous item if switching (BEFORE changing screen values)
        const prevItem = items.find(i => i.key === activeKey);
        if (prevItem && activeKey !== key) {
          console.log(`[selectItem] Switching from ${activeKey} to ${key}, saving previous item`);
          // Update the previous item's value from screen before saving
          const currentScreenValue = clampServings(Number(screen.value));
          if (prevItem.operation === 'add') {
            // For purchase items, screen shows servings/container, NOT quantity
            // Don't update servings, update servingsPerContainer
            prevItem.servingsPerContainer = currentScreenValue;
          } else {
            // For other items (consume/shopping), screen shows quantity
            prevItem.servings = currentScreenValue;
          }
          saveItemImmediate(prevItem);
        }
        
        activeKey = key;
        items.forEach(i => { i.active = (i.key === key); });
        if (it) it.isRed = false; // acknowledge on click
        
        // If selecting a purchase item, show nutrition editor
        if (it && it.operation === 'add') {
          showNutritionEditor(it);
        } else {
          // Not a purchase item - hide nutrition editor and show standard screen
          hideNutritionEditor();
          
          // If item has a unitUsed, restore that unit mode
          if (it && it.unitUsed) {
            unitMode = it.unitUsed;
          }
          // Update screen units based on current mode
          updateScreenUnits();
          
          // Default value: always 1 now that we have unit switcher
          const v = Number.isFinite(it && it.servings) ? it.servings : 1;
          screen.value = String(v);
          
          setTimeout(() => { try { screen.focus(); screen.select(); } catch (_) {} }, 0);
        }
        
        overwriteOnNextDigit = true;
        document.getElementById('activeName').textContent = it ? (it.name || 'Unnamed') : 'No item selected';
        renderQueue();
      }

      function getActiveItem() { return items.find(i => i.key === activeKey) || null; }

      function clampServings(n) { 
        const num = Number(n); 
        if (!Number.isFinite(num)) return scanOp === 'remove' ? 0 : 1; 
        // For consume mode, allow 0; for others, minimum is 1
        const minVal = scanOp === 'remove' ? 0 : 1;
        const v = Math.max(minVal, num); 
        return Math.round(v * 100) / 100; 
      }

      function updateFromScreen() {
        const it = getActiveItem();
        if (!it) return;
        
        console.log(`[updateFromScreen] Item key=${it.key}, servings=${it.servings}, lastConsumedAmount=${it.lastConsumedAmount}`);
        
        const raw = String(screen.value || '');
        // If mid-typing a decimal like "1." or just ".", defer updates
        if (raw === '.' || /^(\d+)\.$/.test(raw)) return;
        const v = clampServings(raw);
        if (!Number.isFinite(v)) return;
        
        console.log(`[updateFromScreen] Updating servings from ${it.servings} to ${v}`);
        
        it.servings = v;
        // Update item's unit to current unit mode (so saveItem knows what to convert)
        it.unitUsed = unitMode;
        scheduleSave(it);
        renderQueue();
      }

      function onDigit(d) {
        if (nutritionEditorVisible && activeNutritionField) {
          const input = document.getElementById(activeNutritionField);
          if (input) {
            if (overwriteOnNextDigit) {
              input.value = String(d);
              overwriteOnNextDigit = false;
            } else {
              const s = String(input.value || '');
              input.value = (s === '0') ? String(d) : (s + String(d));
            }
            input.dispatchEvent(new Event('input'));
          }
        } else {
          if (overwriteOnNextDigit) {
            screen.value = String(d);
            overwriteOnNextDigit = false;
          } else {
            const s = String(screen.value || '');
            screen.value = (s === '0') ? String(d) : (s + String(d));
          }
          updateFromScreen();
        }
      }

      function onBackspace() {
        if (nutritionEditorVisible && activeNutritionField) {
          const input = document.getElementById(activeNutritionField);
          if (input) {
            const s = String(input.value || '');
            input.value = s.length > 1 ? s.slice(0, -1) : '0';
            overwriteOnNextDigit = false;
            input.dispatchEvent(new Event('input'));
          }
        } else {
          const s = String(screen.value || '');
          screen.value = s.length > 1 ? s.slice(0, -1) : '0';
          overwriteOnNextDigit = false;
          updateFromScreen();
        }
      }

      function onDot() {
        if (nutritionEditorVisible && activeNutritionField) {
          const input = document.getElementById(activeNutritionField);
          if (input) {
            const s = String(input.value || '');
            if (s.includes('.')) return;
            if (overwriteOnNextDigit || s === '0') {
              input.value = '0.';
              overwriteOnNextDigit = false;
            } else {
              input.value = s + '.';
            }
            input.dispatchEvent(new Event('input'));
          }
        } else {
          const s = String(screen.value || '');
          if (s.includes('.')) return;
          if (overwriteOnNextDigit || s === '0') {
            screen.value = '0.';
            overwriteOnNextDigit = false;
          } else {
            screen.value = s + '.';
          }
          updateFromScreen();
        }
      }

      function scheduleSave(it) {
        console.log(`[scheduleSave] Scheduling save for item key=${it?.key}, servings=${it?.servings}, lastConsumedAmount=${it?.lastConsumedAmount}`);
        if (saveTimer) {
          console.log(`[scheduleSave] Cancelling previous save timer`);
          clearTimeout(saveTimer);
        }
        // Use immediate save for purchase items (servings per container editing)
        // Use 5 seconds for consume mode, 500ms for shopping
        let delay = 500;
        if (it && it.operation === 'add') {
          delay = 300; // Fast save for servings per container
        } else if (scanOp === 'remove') {
          delay = 5000; // Longer delay for consume mode
        }
        console.log(`[scheduleSave] Will save in ${delay}ms`);
        saveTimer = setTimeout(() => {
          console.log(`[scheduleSave] Timer fired, calling saveItem`);
          saveTimer = null; // Clear the timer reference
          saveItem(it);
        }, delay);
      }
      
      function saveItemImmediate(it) {
        if (saveTimer) clearTimeout(saveTimer);
        saveItem(it);
      }

      async function saveItem(it) {
        console.log(`[FRONTEND] ========== saveItem CALLED ==========`);
        console.log(`[FRONTEND] Item key: ${it?.key}, product_id: ${it?.product_id}, name: ${it?.name}`);
        console.log(`[FRONTEND] Item servings: ${it?.servings}, lastConsumedAmount: ${it?.lastConsumedAmount}`);
        console.log(`[FRONTEND] scanOp: ${scanOp}, operation: ${it?.operation}`);
        
        if (!it || !Number.isFinite(Number(it.product_id))) return; // wait until we know product id
        
        // Prevent concurrent saves of the same item
        if (currentlySaving.has(it.key)) {
          console.log(`[FRONTEND] Save already in progress for item ${it.key}, skipping`);
          return;
        }
        
        currentlySaving.add(it.key);
        
        try {
        
        // For purchase mode OR editing a purchase item (servings per container)
        if (scanOp === 'add' || (it && it.operation === 'add')) {
          // For purchase items, use servingsPerContainer, NOT servings
          const val = Number.isFinite(it.servingsPerContainer) ? it.servingsPerContainer : clampServings(it.servings);
          if (Number(it.lastSavedServings) === val) return;
          try {
            const res = await fetch(`./api/products/${it.product_id}/servings`, {
              method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ servings: val })
            });
            if (!res.ok) throw new Error((await res.json()).error || 'save failed');
            it.lastSavedServings = val;
            it.servingsPerContainer = val; // Update cached value
            
            // Fetch updated stock after setting servings per container
            it.stockAfter = await fetchStockLevel(it.product_id);
            
            statusText.textContent = 'Saved';
            setTimeout(() => { if (statusText.textContent === 'Saved') statusText.textContent = ''; }, 1200);
            renderQueue();
          } catch (e) {
            statusText.textContent = 'Save error: ' + (e && e.message || e);
          }
          return;
        }
        
        // For consume mode, use diff-based approach
        if (scanOp === 'remove') {
          const val = clampServings(it.servings);
          // Fetch stock before consume ONLY if not already set (keep original stock)
          let stockBeforeConsume = it.stockBefore;
          if (!Number.isFinite(stockBeforeConsume)) {
            stockBeforeConsume = await fetchStockLevel(it.product_id);
            it.stockBefore = stockBeforeConsume; // Save the ORIGINAL stock
          }
          
          // Ensure we have servingsPerContainer for proper conversion
          if (!Number.isFinite(it.servingsPerContainer)) {
            try {
              const ufRes = await fetch(`./api/products/${it.product_id}/servings`);
              const ufData = await ufRes.json();
              it.servingsPerContainer = Number.isFinite(ufData.servings) ? ufData.servings : 1;
            } catch {
              it.servingsPerContainer = 1;
            }
          }
          
          // Convert UI value to actual servings based on unit mode
          let actualServings = val;
          
          // Check unit mode stored in item
          const currentUnitMode = it.unitUsed || unitMode;
          
          if (currentUnitMode === 'containers') {
            // User entered containers, convert to servings
            actualServings = val * it.servingsPerContainer;
          } else {
            // User entered servings, use as-is
            actualServings = val;
          }
          
          // Legacy: if val is 0, treat as 1 full container
          if (val === 0) {
            actualServings = it.servingsPerContainer;
          }
          
          console.log(`[FRONTEND] Product ${it.product_id}: Keypad=${val}, Unit=${currentUnitMode}`);
          console.log(`[FRONTEND] servingsPerContainer cached: ${it.servingsPerContainer}`);
          console.log(`[FRONTEND] Converting to servings: ${actualServings}`);
          console.log(`[FRONTEND] Expected containers: ${actualServings / it.servingsPerContainer}`);
          
          const lastConsumed = Number(it.lastConsumedAmount) || 0;
          console.log(`[FRONTEND] lastConsumedAmount BEFORE save: ${it.lastConsumedAmount}`);
          console.log(`[FRONTEND] lastConsumed (normalized): ${lastConsumed}`);
          
          if (lastConsumed === actualServings) {
            console.log(`[FRONTEND] No change needed, actualServings=${actualServings} matches lastConsumed=${lastConsumed}`);
            return; // No change
          }
          
          const diff = actualServings - lastConsumed;
          console.log(`[FRONTEND] DIFF CALCULATION: ${actualServings} - ${lastConsumed} = ${diff}`);
          console.log(`[FRONTEND] Will ${diff > 0 ? 'CONSUME' : 'ADD'} ${Math.abs(diff)} servings (${Math.abs(diff / it.servingsPerContainer)} containers)`);
          
          try {
            // Consume or purchase the difference
            // Note: We pass servings to the backend, which converts to containers
            // e.g., 1 serving with 2 servings/container = 0.5 containers consumed in Grocy
            if (diff !== 0) {
              const res = await fetch(`./api/consume-or-purchase`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                  product_id: it.product_id, 
                  amount: diff // Amount in SERVINGS - backend converts to containers
                })
              });
              if (!res.ok) throw new Error((await res.json()).error || 'operation failed');
            }
            
            // Update meal plan if this is a meal plan item
            if (it.isMealPlanItem && it.mealPlanEntryId) {
              const mpRes = await fetch(`./api/meal-plan/${it.mealPlanEntryId}/servings`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ servings: actualServings })
              });
              if (!mpRes.ok) throw new Error((await mpRes.json()).error || 'meal plan update failed');
            }
            
            // Fetch stock after consume
            const stockAfterConsume = await fetchStockLevel(it.product_id);
            // Don't update stockBefore - keep the original value from first scan
            it.stockAfter = stockAfterConsume;
            it.unitUsed = unitMode; // Update unit used
            
            console.log(`[FRONTEND] SAVE COMPLETE - Setting lastConsumedAmount from ${it.lastConsumedAmount} to ${actualServings}`);
            it.lastConsumedAmount = actualServings;
            console.log(`[FRONTEND] lastConsumedAmount AFTER save: ${it.lastConsumedAmount}`);
            console.log(`[FRONTEND] Stock changed: ${stockBeforeConsume} ‚Üí ${stockAfterConsume}`);
            
            statusText.textContent = 'Saved';
            setTimeout(() => { if (statusText.textContent === 'Saved') statusText.textContent = ''; }, 1200);
            renderQueue();
          } catch (e) {
            statusText.textContent = 'Save error: ' + (e && e.message || e);
          }
          return;
        }
        
        // For shopping mode, directly set the amount in shopping list
        if (scanOp === 'shopping' || (it && it.operation === 'shopping')) {
          const newAmount = clampServings(it.servings);
          
          try {
            // Get current amount in shopping list
            const amountRes = await fetch(`./api/shopping/amount/${it.product_id}?shopping_list_id=${APP_CONFIG.default_shopping_list_id}`);
            const amountData = await amountRes.json();
            const currentAmount = Number(amountData.amount || 0);
            
            if (currentAmount === newAmount) return; // No change needed
            
            const diff = newAmount - currentAmount;
            
            if (diff > 0) {
              // Add more to shopping list
              const res = await fetch(`./api/shopping/add`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ product_id: it.product_id, amount: diff })
              });
              if (!res.ok) throw new Error((await res.json()).error || 'add failed');
            } else if (diff < 0) {
              // Remove from shopping list
              const res = await fetch(`./api/shopping/remove`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ product_id: it.product_id, amount: Math.abs(diff) })
              });
              if (!res.ok) throw new Error((await res.json()).error || 'remove failed');
            }
            
            statusText.textContent = 'Saved';
            setTimeout(() => { if (statusText.textContent === 'Saved') statusText.textContent = ''; }, 1200);
            renderQueue();
          } catch (e) {
            statusText.textContent = 'Save error: ' + (e && e.message || e);
          }
        }
        
        } finally {
          // Always clear the saving flag, even on early returns
          currentlySaving.delete(it.key);
          console.log(`[FRONTEND] Cleared saving flag for item ${it.key}`);
        }
      }

      // Keypad wiring
      document.querySelectorAll('[data-digit]').forEach(btn => btn.addEventListener('click', () => onDigit(Number(btn.dataset.digit))));
      document.querySelector('[data-act="backspace"]').addEventListener('click', onBackspace);
      const dotBtn = document.querySelector('[data-act="dot"]'); if (dotBtn) dotBtn.addEventListener('click', onDot);
      btnUnitToggle.addEventListener('click', toggleUnit);
      screen.addEventListener('input', () => { overwriteOnNextDigit = false; updateFromScreen(); });

      // Scanning flow: enqueue job, then attach item to queue, then enrich via summary
      barcodeInput.addEventListener('keydown', async (e) => {
        if (e.key === 'Enter') { e.preventDefault(); await submitScan(); }
      });
      
      // Save current item when barcode input is focused
      barcodeInput.addEventListener('focus', () => {
        const activeItem = getActiveItem();
        if (activeItem) {
          saveItemImmediate(activeItem);
        }
      });

      // Global barcode scanner detector: capture rapid digits followed by Enter and redirect to barcode input
      let scanBuffer = '';
      let lastKeystrokeTime = 0;
      const SCAN_SPEED_THRESHOLD = 50; // ms between keys to consider as scanner input
      const MIN_BARCODE_LENGTH = 6;
      const MAX_BARCODE_LENGTH = 24;
      let scanResetTimer = null;
      let scanningBurstActive = false; // true when we've identified a scanner burst
      let screenPrevValue = null; // keypad screen previous value when burst starts

      function isProtectedTarget(el) {
        if (!el) return false;
        // Do not intercept when typing in known inputs
        if (el.id && (
          el.id === 'tempItemName' ||
          el.id === 'tempItemCals' ||
          el.id === 'tempItemCarbs' ||
          el.id === 'tempItemFats' ||
          el.id === 'tempItemProtein' ||
          el.id === 'barcode' // already in barcode box
        )) return true;
        if (el.classList && (
          el.classList.contains('customLinkInput') ||
          el.classList.contains('manualPriceInput')
        )) return true;
        const tag = (el.tagName || '').toLowerCase();
        // Allow interception for keypad 'screen' input; protect other inputs
        if ((tag === 'input' || tag === 'textarea') && el.id !== 'screen') return true;
        return false;
      }

      function resetScanBufferSoon() {
        if (scanResetTimer) clearTimeout(scanResetTimer);
        // Clear buffer if no activity for 300ms
        scanResetTimer = setTimeout(() => { scanBuffer = ''; scanningBurstActive = false; }, 300);
      }

      document.addEventListener('keydown', (e) => {
        try {
          const activeEl = document.activeElement;
          const isScreenFocused = !!(activeEl && activeEl.id === 'screen');
          // Don't intercept when the user is typing in protected fields (except keypad screen)
          if (isProtectedTarget(activeEl)) { scanBuffer = ''; scanningBurstActive = false; return; }

          const now = Date.now();
          const delta = now - lastKeystrokeTime;

          // Digits: accumulate into buffer when arriving quickly (scanner-like)
          if (e.key >= '0' && e.key <= '9') {
            if (isScreenFocused) {
              // Special handling to avoid mutating keypad screen when detecting a scan burst
              if (scanBuffer.length === 0) {
                // Capture previous value on first digit
                screenPrevValue = screen.value;
              }

              if (delta < SCAN_SPEED_THRESHOLD || scanBuffer.length === 0) {
                scanBuffer += e.key;
                // If this is the second fast digit, treat as scanner and prevent input effects
                if (!scanningBurstActive && scanBuffer.length >= 2 && delta < SCAN_SPEED_THRESHOLD) {
                  scanningBurstActive = true;
                  // Prevent current key from affecting the screen and revert first digit side-effect
                  e.preventDefault();
                  if (screenPrevValue != null) {
                    screen.value = screenPrevValue;
                    try { if (saveTimer) clearTimeout(saveTimer); } catch (_) {}
                  }
                } else if (scanningBurstActive) {
                  e.preventDefault();
                }
              } else {
                // Slow typing -> human; reset scanner detection
                scanBuffer = e.key;
                scanningBurstActive = false;
              }

              lastKeystrokeTime = now;
              resetScanBufferSoon();
              return;
            } else {
              // Non-screen context: accumulate but don't block default behavior
              if (delta < SCAN_SPEED_THRESHOLD || scanBuffer.length === 0) {
                scanBuffer += e.key;
              } else {
                scanBuffer = e.key;
              }
              lastKeystrokeTime = now;
              resetScanBufferSoon();
              return;
            }
          }

          // Enter (or NumpadEnter): commit if buffer looks like a barcode
          if ((e.key === 'Enter' || e.code === 'NumpadEnter') && scanBuffer.length >= MIN_BARCODE_LENGTH && scanBuffer.length <= MAX_BARCODE_LENGTH) {
            e.preventDefault();
            e.stopPropagation();
            barcodeInput.value = scanBuffer;
            scanBuffer = '';
            scanningBurstActive = false;
            try { barcodeInput.focus(); } catch (_) {}
            // Submit the scan
            submitScan();
            return;
          }

          // Any other key (besides modifiers) clears the buffer
          const isModifier = (e.key === 'Shift' || e.key === 'Control' || e.key === 'Alt' || e.key === 'Meta');
          if (!isModifier) {
            scanBuffer = '';
            scanningBurstActive = false;
          }
        } catch (_) {
          // Fail-safe: do not block user input on errors
          scanBuffer = '';
          scanningBurstActive = false;
        }
      });

      async function submitScan() {
        const barcode = barcodeInput.value.trim();
        if (!barcode) { statusText.textContent = 'Enter a barcode'; return; }
        
        // Handle shopping mode differently - directly add to shopping list
        if (scanOp === 'shopping') {
          statusText.textContent = 'Looking up product...';
          try {
            // Get product by barcode
            const summaryRes = await fetch(`./api/products/summary/by-barcode/${encodeURIComponent(barcode)}`);
            const summary = await summaryRes.json();
            
            if (!summary.exists || !Number.isFinite(Number(summary.product_id))) {
              statusText.textContent = 'Product not found. Scan in Purchase mode first.';
              beepBad();
              setTimeout(() => { statusText.textContent = ''; }, 2000);
              barcodeInput.value = '';
              barcodeInput.focus();
              return;
            }
            
            const pid = Number(summary.product_id);
            
            // Get current amount in shopping list BEFORE adding
            statusText.textContent = 'Checking shopping list...';
            const amountResBefore = await fetch(`./api/shopping/amount/${pid}?shopping_list_id=${APP_CONFIG.default_shopping_list_id}`);
            const amountDataBefore = await amountResBefore.json();
            const amountBefore = Number(amountDataBefore.amount || 0);
            
            // Add to shopping list
            const amountToAdd = 1; // Always add 1 container in shopping mode
            statusText.textContent = 'Adding to shopping list...';
            const addRes = await fetch(`./api/shopping/add`, { 
              method: 'POST', 
              headers: { 'Content-Type': 'application/json' }, 
              body: JSON.stringify({ product_id: pid, amount: amountToAdd }) 
            });
            const addData = await addRes.json();
            
            if (!addRes.ok) throw new Error(addData && addData.error || 'Failed to add');
            
            // Get actual amount in shopping list AFTER adding
            const amountResAfter = await fetch(`./api/shopping/amount/${pid}?shopping_list_id=${APP_CONFIG.default_shopping_list_id}`);
            const amountDataAfter = await amountResAfter.json();
            const amountAfter = Number(amountDataAfter.amount || 0);
            
            // Create item in queue for visual feedback
            const key = `${Date.now()}_${Math.random().toString(36).slice(2)}`;
            const item = {
              key,
              barcode,
              product_id: pid,
              name: summary.name || 'Unknown',
              servings: amountAfter, // Total amount in shopping list
              isRed: false,
              active: false,
              lastSavedServings: amountBefore, // Amount BEFORE this scan (for diff calculation)
              mealPlanEntryId: null,
              isMealPlanItem: false,
              lastConsumedAmount: null,
              operation: 'shopping',
              unitUsed: 'containers',
              stockBefore: null,
              stockAfter: null,
              isNew: false,
              servingsPerContainer: null,
              amountAdded: amountToAdd // Track how much was added in this scan
            };
            items.unshift(item);
            if (items.length > 100) items = items.slice(0, 100);
            renderQueue();
            
            statusText.textContent = `Added ${summary.name} to shopping list`;
            setTimeout(() => { if (statusText.textContent.startsWith('Added')) statusText.textContent = ''; }, 1500);
            barcodeInput.value = '';
            barcodeInput.focus();
          } catch (err) {
            statusText.textContent = 'Error: ' + err.message;
            beepBad();
            setTimeout(() => { statusText.textContent = ''; }, 2000);
          }
          return;
        }
        
        /* removed limit on number of new items */
        statusText.textContent = 'Submitting...';
        try {
          const res = await fetch(`./api/scan/${scanOp}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ barcode }) });
          const data = await res.json();
          if (!res.ok) throw new Error(data && data.error || 'Request failed');
          const key = `${Date.now()}_${Math.random().toString(36).slice(2)}`;
          // Set default servings and unit based on mode and meal plan state
          let defaultServings = 1;
          let defaultUnit = unitMode;
          if (scanOp === 'add') {
            defaultServings = 1;
            defaultUnit = 'containers';
          } else if (scanOp === 'remove') {
            defaultServings = 1;
            defaultUnit = mealPlanEnabled ? 'servings' : 'containers';
          } else if (scanOp === 'shopping') {
            defaultServings = 1;
            defaultUnit = 'containers';
          }
          
          const item = { 
            key, 
            barcode, 
            product_id: null, 
            name: 'Scanning‚Ä¶', 
            servings: defaultServings, 
            isRed: false, 
            active: false, 
            lastSavedServings: null,
            mealPlanEntryId: null,
            isMealPlanItem: false,
            lastConsumedAmount: null,
            operation: scanOp,
            unitUsed: defaultUnit,
            stockBefore: null,
            stockAfter: null,
            isNew: false,
            servingsPerContainer: null
          };
          items.unshift(item);
          if (items.length > 100) items = items.slice(0, 100);
          // do not auto-select; keep keypad inactive until user clicks an item
          barcodeInput.value = ''; barcodeInput.focus();
          renderQueue();
          pollJob(data.jobId, barcode, key);
        } catch (err) {
          statusText.textContent = 'Error: ' + err.message;
        }
      }

      async function pollJob(jobId, barcode, key) {
        const currentOp = scanOp; // Capture current operation mode
        while (true) {
          await new Promise(r => setTimeout(r, 700));
          const res = await fetch(`./api/jobs/${jobId}`);
          const data = await res.json();
          if (!res.ok) { statusText.textContent = 'Job error: ' + (data && data.error); return; }
          
          const jobStatus = (data.status || '').toLowerCase();
          const jobResult = data.result || {};
          const wasSuccessful = Boolean(jobResult.success === true || jobResult.status === 'ok');

          if (jobStatus === 'completed') {
            if (wasSuccessful) {
              statusText.textContent = 'Success';

              // If meal plan toggle is enabled and we're in consume mode, add to meal plan
              if (mealPlanEnabled && currentOp === 'remove') {
                try {
                  await addConsumedItemToMealPlan(barcode, key);
                  statusText.textContent = 'Success + Added to Meal Plan';
                } catch (err) {
                  console.error('Failed to add to meal plan:', err);
                  statusText.textContent = 'Success (meal plan add failed)';
                }
              }
            } else {
              const errorMsg = jobResult.error || jobResult.message || 'Unknown error';
              statusText.textContent = 'Failed: ' + errorMsg;
            }

            try { await enrichItemFromSummary(barcode, key, jobResult, currentOp); } catch (_) {}
            setTimeout(() => { 
              if (statusText.textContent.startsWith('Success')) statusText.textContent = ''; 
            }, 1200);
            return;
          }

          if (jobStatus === 'failed') {
            const errorMsg = jobResult.error || jobResult.message || 'Unknown error';
            statusText.textContent = 'Failed: ' + errorMsg;
            try { await enrichItemFromSummary(barcode, key, jobResult, currentOp); } catch (_) {}
            return;
          }

          if (jobStatus === 'cancelled' || jobStatus === 'cancelled_by_user' || jobStatus === 'cancelled_by_system') {
            statusText.textContent = 'Cancelled';
            return;
          }
        }
      }
      
      async function addConsumedItemToMealPlan(barcode, key) {
        // Get product by barcode
        const summaryRes = await fetch(`./api/products/summary/by-barcode/${encodeURIComponent(barcode)}`);
        const summary = await summaryRes.json();
        
        if (!summary.exists || !Number.isFinite(Number(summary.product_id))) {
          throw new Error('Product not found');
        }
        
        const productId = Number(summary.product_id);
        
        // Find the item in the queue
        const item = items.find(i => i.key === key);
        if (!item) throw new Error('Item not found in queue');
        
        // Get the servings value from item
        let servingsValue = Number.isFinite(item.servings) ? item.servings : 1;

        // Get current day from backend (respects custom day boundaries)
        const daySummaryRes = await fetch('./api/macros/day-summary');
        const daySummary = await daySummaryRes.json();
        const today = daySummary.day; // Use day from backend which respects DAY_START_TIME

        // Always fetch servingsPerContainer for proper conversion
        let servingsPerContainer = 1;
        try {
          const ufRes = await fetch(`./api/products/${productId}/servings`);
          const ufData = await ufRes.json();
          servingsPerContainer = Number.isFinite(ufData.servings) ? ufData.servings : 1;
        } catch {
          servingsPerContainer = 1; // Fallback
        }

        // Convert to actual servings based on unit mode (same logic as saveItem)
        let actualServings = servingsValue;
        const currentUnitMode = item.unitUsed || unitMode;

        if (currentUnitMode === 'containers') {
          // User consumed containers, convert to servings
          actualServings = servingsValue * servingsPerContainer;
        } else {
          // Already in servings, use as-is
          actualServings = servingsValue;
        }

        // GROCY BUG WORKAROUND: Grocy treats product_amount as containers regardless of product_qu_id
        // We need to use the Servings qu_id and convert the amount to container-equivalents
        // Example: 2 servings with 2 servings/container -> amount = 2 * (1/2) = 1.0 container

        // Get quantity units and find Servings qu_id
        const quUnitsRes = await fetch('./api/proxy/objects/quantity_units');
        const quUnits = await quUnitsRes.json();
        let servingsQuId = null;
        for (const qu of quUnits) {
          const name = (qu.name || '').toLowerCase();
          if (name.includes('serving') || name.includes('portion')) {
            servingsQuId = qu.id;
            break;
          }
        }

        // Get product details to find stock unit
        const productRes = await fetch(`./api/proxy/objects/products/${productId}`);
        const productData = await productRes.json();
        const stockQuId = productData.qu_id_stock;

        // Get quantity unit conversions to find serving -> container factor
        const conversionsRes = await fetch('./api/proxy/objects/quantity_unit_conversions');
        const conversions = await conversionsRes.json();
        let conversionFactor = null;

        if (servingsQuId) {
          for (const conv of conversions) {
            if (Number(conv.product_id) === Number(productId) && Number(conv.from_qu_id) === Number(servingsQuId)) {
              // Found conversion from Serving to Container
              conversionFactor = parseFloat(conv.factor || 0);
              break;
            }
          }
        }

        // GROCY MEAL PLAN DISPLAY FIX:
        // Send as CONTAINERS (stock unit) with converted amount
        // Example: 1 serving with 5 servings/container ‚Üí 0.2 containers
        let mealPlanAmount = actualServings;
        let mealPlanQuId = stockQuId; // Always use stock unit (Container)

        if (conversionFactor && conversionFactor > 0) {
          // Apply conversion: servings * (containers/serving) = containers
          mealPlanAmount = actualServings * conversionFactor;
        } else {
          // No conversion found, calculate from servingsPerContainer
          mealPlanAmount = actualServings / servingsPerContainer;
        }

        console.log(`[addConsumedItemToMealPlan] Product ${productId}: servingsValue=${servingsValue}, unitMode=${currentUnitMode}`);
        console.log(`[addConsumedItemToMealPlan] servingsPerContainer=${servingsPerContainer}, actualServings=${actualServings}`);
        console.log(`[addConsumedItemToMealPlan] Servings qu_id=${servingsQuId}, conversionFactor=${conversionFactor}`);
        console.log(`[addConsumedItemToMealPlan] Meal plan: amount=${mealPlanAmount}, qu_id=${mealPlanQuId}`);

        // Add to meal plan
        const payload = {
          day: today,
          type: 'product',
          product_id: productId,
          product_amount: mealPlanAmount,
          product_qu_id: mealPlanQuId
        };
        console.log('[addConsumedItemToMealPlan] POST payload:', JSON.stringify(payload));

        const addRes = await fetch('./api/proxy/objects/meal_plan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        console.log('[addConsumedItemToMealPlan] POST response status:', addRes.status, addRes.statusText);

        if (!addRes.ok) {
          const errText = await addRes.text();
          console.error('[addConsumedItemToMealPlan] POST failed. Response:', errText);
          throw new Error(errText || 'Failed to add to meal plan');
        }
        
        const mealPlanEntry = await addRes.json();
        const entryId = mealPlanEntry.created_object_id || mealPlanEntry.id;
        console.log('[addConsumedItemToMealPlan] Entry created! ID:', entryId, 'Response:', mealPlanEntry);

        // Mark as done if we got an entry ID
        if (entryId) {
          console.log('[addConsumedItemToMealPlan] Marking entry', entryId, 'as done...');
          const doneFields = ['done', 'is_done', 'completed'];
          for (const field of doneFields) {
            try {
              await fetch(`./api/proxy/objects/meal_plan/${entryId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ [field]: true })
              });
              console.log('[addConsumedItemToMealPlan] Successfully marked entry as done using field:', field);
              break; // Success, exit loop
            } catch (err) {
              console.warn('[addConsumedItemToMealPlan] Failed to mark as done with field:', field, err);
              // Try next field
            }
          }

          // Update the item to mark it as a meal plan item
          item.mealPlanEntryId = entryId;
          item.isMealPlanItem = true;
          item.lastConsumedAmount = actualServings;
          item.servings = actualServings; // Update displayed servings
          renderQueue();
          console.log('[addConsumedItemToMealPlan] SUCCESS! Entry', entryId, 'created and marked as done');
        } else {
          console.error('[addConsumedItemToMealPlan] No entry ID returned!');
        }

        return entryId;
      }

      async function enrichItemFromSummary(barcode, key, jobResult, operationMode) {
        try {
          const res = await fetch(`./api/products/summary/by-barcode/${encodeURIComponent(barcode)}`);
          const s = await res.json();
          const it = items.find(i => i.key === key);
          if (!it) return;
          if (s && s.exists) {
            it.product_id = Number(s.product_id);
            it.name = s.name || it.name;
            // Mark red only if job created a product; existing products are not red
            const wasCreated = !!(jobResult && jobResult.created_product);
            it.isRed = wasCreated;
            it.isNew = wasCreated;
            
            // Fetch servings per container
            try {
              const ufRes = await fetch(`./api/products/${it.product_id}/servings`);
              const ufData = await ufRes.json();
              it.servingsPerContainer = Number.isFinite(ufData.servings) ? ufData.servings : 1;
            } catch {
              it.servingsPerContainer = 1;
            }
            
            // Fetch stock levels for purchase and consume operations
            if (operationMode === 'add') {
              // Purchase: fetch stock after purchase
              it.stockAfter = await fetchStockLevel(it.product_id);
              console.log('Purchase - stockAfter:', it.stockAfter);
            } else if (operationMode === 'remove') {
              // Consume: Backend no longer consumes immediately, we handle it here
              it.stockBefore = await fetchStockLevel(it.product_id);
              
              // Set initial lastConsumedAmount to 0 (nothing consumed yet)
              it.lastConsumedAmount = 0;
              
              // Set default servings based on meal plan state
              it.servings = 1;
              // Set unit based on meal plan state
              it.unitUsed = it.isMealPlanItem ? 'servings' : 'containers';
              
              // Reset global unitMode to match this item's default
              unitMode = it.unitUsed;
              updateScreenUnits();
              
              // Trigger initial consume with the default amount
              console.log('Consume - Initial scan, will consume default amount...');
              setTimeout(() => saveItem(it), 500); // Save after a short delay
            }
            
            // Ignore any 'servings' in summary response to avoid prefill
            // Now that we know the product id, persist current servings only if user changes
            renderQueue();
          }
        } catch (_) {}
      }

      // Start with an empty queue and focus scanner input
      updateScreenUnits(); // Initialize units display
      renderQueue();
      setTimeout(() => { try { barcodeInput.focus(); } catch (_) {} }, 0);

      // =====================
      // Recipe Search Functions
      // =====================

      function searchRecipes() {
        const params = new URLSearchParams();

        if (document.getElementById('filterCanBeMade').checked) {
          params.append('can_be_made', 'true');
        }

        // Carbs percentile filter
        const carbsPercentile = parseFloat(document.getElementById('filterCarbsMin').value);
        if (carbsPercentile > 0 && recipeCarbsDensities.length > 0) {
          if (carbsPercentile === 100) {
            // Special case: At 100%, show only top 4 recipes
            if (recipeCarbsDensities.length >= 4) {
              const fourthHighest = recipeCarbsDensities[3].carbs_per_100cal;
              params.append('min_carbs_per_100cal', fourthHighest);
            } else if (recipeCarbsDensities.length > 0) {
              // If less than 4 recipes, use the lowest value to get all of them
              const lowest = recipeCarbsDensities[recipeCarbsDensities.length - 1].carbs_per_100cal;
              params.append('min_carbs_per_100cal', lowest);
            }
          } else {
            // Calculate the index for the given percentile
            // carbsPercentile of 50 means top 50%, so we want that many recipes
            // Number of recipes to show = ceil(percentile% * total)
            // The threshold is the carbs value of the last recipe in that group
            const numRecipesToShow = Math.ceil((carbsPercentile / 100) * recipeCarbsDensities.length);
            if (numRecipesToShow > 0 && numRecipesToShow <= recipeCarbsDensities.length) {
              const lastIndex = numRecipesToShow - 1;
              const thresholdValue = recipeCarbsDensities[lastIndex].carbs_per_100cal;
              params.append('min_carbs_per_100cal', thresholdValue);
            }
          }
        }

        // Protein percentile filter
        const proteinPercentile = parseFloat(document.getElementById('filterProteinMin').value);
        if (proteinPercentile > 0 && recipeProteinDensities.length > 0) {
          if (proteinPercentile === 100) {
            // Special case: At 100%, show only top 4 recipes
            // We'll handle this by setting a very high threshold (get the 4th highest value)
            if (recipeProteinDensities.length >= 4) {
              const fourthHighest = recipeProteinDensities[3].protein_per_100cal;
              params.append('min_protein_per_100cal', fourthHighest);
            } else if (recipeProteinDensities.length > 0) {
              // If less than 4 recipes, use the lowest value to get all of them
              const lowest = recipeProteinDensities[recipeProteinDensities.length - 1].protein_per_100cal;
              params.append('min_protein_per_100cal', lowest);
            }
          } else {
            // Calculate the index for the given percentile
            // proteinPercentile of 50 means top 50%, so we want that many recipes
            // Number of recipes to show = ceil(percentile% * total)
            // The threshold is the protein value of the last recipe in that group
            const numRecipesToShow = Math.ceil((proteinPercentile / 100) * recipeProteinDensities.length);
            if (numRecipesToShow > 0 && numRecipesToShow <= recipeProteinDensities.length) {
              const lastIndex = numRecipesToShow - 1;
              const thresholdValue = recipeProteinDensities[lastIndex].protein_per_100cal;
              params.append('min_protein_per_100cal', thresholdValue);
            }
          }
        }

        // Time filters
        const activeMax = parseInt(document.getElementById('filterActiveTimeMax').value);
        if (activeMax < 45) params.append('max_active_time', activeMax);

        const totalMax = parseInt(document.getElementById('filterTotalTimeMax').value);
        if (totalMax < 45) params.append('max_total_time', totalMax);

        // Fetch results
        fetch(`./api/recipes/search?${params}`)
          .then(r => r.json())
          .then(data => {
            const recipes = data.recipes || [];
            document.getElementById('recipeCount').textContent = `(${recipes.length})`;

            const grid = document.getElementById('recipesGrid');
            grid.innerHTML = '';

            recipes.forEach(recipe => {
              const card = document.createElement('div');
              card.className = 'recipeCard';
              card.innerHTML = `
                <div class="recipeName">
                  ${recipe.name || 'Unnamed Recipe'}
                  ${recipe.meal_plan_count > 0 ? `<span style="color: #4CAF50; font-weight: bold; margin-left: 8px;">(${recipe.meal_plan_count})</span>` : ''}
                </div>
                ${recipe.description ? `<div class="recipeDescription">${recipe.description}</div>` : ''}
                <div class="recipeMacros">
                  <div class="macroItem">
                    <span class="value">${recipe.calories}</span>
                    <span>cal</span>
                  </div>
                  <div class="macroItem">
                    <span class="value">${recipe.carbs}g</span>
                    <span>carbs</span>
                  </div>
                  <div class="macroItem">
                    <span class="value">${recipe.fats}g</span>
                    <span>fats</span>
                  </div>
                  <div class="macroItem">
                    <span class="value">${recipe.protein}g</span>
                    <span>protein</span>
                  </div>
                </div>
                <div class="recipeTime">
                  ${recipe.active_time ? `<span>Active: ${recipe.active_time} min</span>` : ''}
                  ${recipe.total_time ? `<span>Total: ${recipe.total_time} min</span>` : ''}
                </div>
              `;
              
              // Add "Add to Today" button
              const addButton = document.createElement('button');
              addButton.textContent = 'Add to Today';
              addButton.className = 'managerBtn';
              addButton.style.cssText = 'width: 100%; margin-top: 12px; padding: 8px;';
              addButton.onclick = () => addRecipeToToday(recipe.id, recipe.base_servings || 1, recipe.name, addButton);
              card.appendChild(addButton);
              
              grid.appendChild(card);
            });
          })
          .catch(err => {
            console.error('Error searching recipes:', err);
            alert('Error searching recipes');
          });
      }
      
      async function addRecipeToToday(recipeId, servings, recipeName, buttonElement) {
        try {
          // Disable button while processing
          buttonElement.disabled = true;
          buttonElement.textContent = 'Adding...';
          
          // Get current day from backend (respects custom day boundaries)
          const daySummaryRes = await fetch('./api/macros/day-summary');
          const daySummary = await daySummaryRes.json();
          const today = daySummary.day; // Use day from backend which respects DAY_START_TIME
          
          // Add recipe to meal plan for today
          const addRes = await fetch('./api/proxy/objects/meal_plan', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              day: today,
              type: 'recipe',
              recipe_id: recipeId,
              recipe_servings: servings
            })
          });
          
          if (!addRes.ok) {
            const errData = await addRes.json();
            throw new Error(errData.error || 'Failed to add to meal plan');
          }
          
          // Success - change button to green with confirmation
          buttonElement.style.background = '#4CAF50';
          buttonElement.textContent = `‚úì Added (${servings} serving${servings !== 1 ? 's' : ''})`;
          buttonElement.disabled = false;
        } catch (err) {
          console.error('Error adding recipe to meal plan:', err);
          // Error - change button to red with error message
          buttonElement.style.background = '#f44336';
          buttonElement.textContent = '‚úó Failed - Click to retry';
          buttonElement.disabled = false;
        }
      }

      // Update slider value displays
      // Macro min sliders
      ['Carbs', 'Protein'].forEach(macro => {
        const slider = document.getElementById(`filter${macro}Min`);
        const display = document.getElementById(`filter${macro}MinValue`);
        if (slider && display) {
          slider.addEventListener('input', () => {
            display.textContent = slider.value;
          });
        }
      });

      // Time max sliders
      ['ActiveTime', 'TotalTime'].forEach(time => {
        const slider = document.getElementById(`filter${time}Max`);
        const display = document.getElementById(`filter${time}MaxValue`);
        if (slider && display) {
          slider.addEventListener('input', () => {
            display.textContent = slider.value;
          });
        }
      });
    </script>
  </body>
  </html>
